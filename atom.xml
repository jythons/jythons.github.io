<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[奔跑在草原上的键盘手]]></title>
  <link href="jythons.github.io/atom.xml" rel="self"/>
  <link href="jythons.github.io/"/>
  <updated>2023-08-10T13:59:57+08:00</updated>
  <id>jythons.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[php7.1以上版本安装ds拓展]]></title>
    <link href="jythons.github.io/16915611066736.html"/>
    <updated>2023-08-09T14:05:06+08:00</updated>
    <id>jythons.github.io/16915611066736.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="%E4%BD%BF%E7%94%A8pecl%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true" href="#%E4%BD%BF%E7%94%A8pecl%E5%AE%89%E8%A3%85"><span class="octicon octicon-link"></span></a>使用pecl安装</h2>
<h3><a id="%E6%8A%A5%E9%94%99" class="anchor" aria-hidden="true" href="#%E6%8A%A5%E9%94%99"><span class="octicon octicon-link"></span></a>报错</h3>
<pre><code class="language-shell">/opt/homebrew/Cellar/php@7.4/7.4.26_1/include/php/ext/pcre/php_pcre.h:25:10: fatal error: 'pcre2.h' file not found
</code></pre>
<h3><a id="%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="anchor" aria-hidden="true" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="octicon octicon-link"></span></a>解决办法</h3>
<pre><code class="language-shell">ln -s /opt/homebrew/include/pcre2.h /opt/homebrew/Cellar/php@7.4/7.4.26_1/include/php/ext/pcre/pcre2.h
</code></pre>
<blockquote>
<p>在对应的报错目录下添加需要使用的文件即可</p>
</blockquote>
<h2><a id="ds%E6%8B%93%E5%B1%95%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true" href="#ds%E6%8B%93%E5%B1%95%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="octicon octicon-link"></span></a>DS拓展使用官方文档</h2>
<p><a href="https://www.php.net/manual/zh/class.ds-collection.php">https://www.php.net/manual/zh/class.ds-collection.php</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker日常命令（持续更新...）]]></title>
    <link href="jythons.github.io/16906398618868.html"/>
    <updated>2023-07-29T22:11:01+08:00</updated>
    <id>jythons.github.io/16906398618868.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8ip" class="anchor" aria-hidden="true" href="#%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8ip"><span class="octicon octicon-link"></span></a>获取容器IP</h2>
<pre><code class="language-shell">docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' {容器ID}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日常开发错误]]></title>
    <link href="jythons.github.io/16904527687916.html"/>
    <updated>2023-07-27T18:12:48+08:00</updated>
    <id>jythons.github.io/16904527687916.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="%E9%94%99%E8%AF%AF1" class="anchor" aria-hidden="true" href="#%E9%94%99%E8%AF%AF1"><span class="octicon octicon-link"></span></a>错误1</h2>
<p><strong>错误：</strong></p>
<blockquote>
<p>grpc客户端调用服务端时，报如下错误：</p>
</blockquote>
<pre><code class="language-go">grpc panic: runtime error: invalid memory address or nil pointer dereference
</code></pre>
<p><strong>原因：</strong><br />
可能使用的调用方法是老版本。<br />
<strong>解决：</strong><br />
使用如下方法连接服务端即可</p>
<pre><code class="language-go">conn, err := grpc.Dial(&quot;localhost:&quot;+port, grpc.WithTransportCredentials(insecure.NewCredentials()))
</code></pre>
<blockquote>
<p>友情提示：<br />
开发时，吧所有错误都判断一下，方便根据提示信息定位问题。不要偷懒，使用“_”忽略err。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下安装Protobuf]]></title>
    <link href="jythons.github.io/16901201569851.html"/>
    <updated>2023-07-23T21:49:16+08:00</updated>
    <id>jythons.github.io/16901201569851.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="%E5%AE%89%E8%A3%85protobuf" class="anchor" aria-hidden="true" href="#%E5%AE%89%E8%A3%85protobuf"><span class="octicon octicon-link"></span></a>安装protobuf</h2>
<pre><code class="language-shell">brew install protobuf
</code></pre>
<h2><a id="%E6%A3%80%E6%9F%A5%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true" href="#%E6%A3%80%E6%9F%A5%E5%AE%89%E8%A3%85%E7%BB%93%E6%9E%9C"><span class="octicon octicon-link"></span></a>检查安装结果</h2>
<pre><code class="language-shell">protoc  --version
</code></pre>
<h2><a id="%E5%AE%89%E8%A3%85golang-for-protobuf%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true" href="#%E5%AE%89%E8%A3%85golang-for-protobuf%E6%8F%92%E4%BB%B6"><span class="octicon octicon-link"></span></a>安装golang for protobuf插件</h2>
<pre><code class="language-shell">go get -u -v github.com/golang/protobuf/protoc-gen-go

go v1.17以上版本使用如下命令安装
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
</code></pre>
<h2><a id="%E8%BF%90%E7%94%A8%EF%BC%8C%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%87%8C%E8%BF%90%E8%A1%8C" class="anchor" aria-hidden="true" href="#%E8%BF%90%E7%94%A8%EF%BC%8C%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%87%8C%E8%BF%90%E8%A1%8C"><span class="octicon octicon-link"></span></a>运用，在文件目录里运行</h2>
<pre><code class="language-shell"># protoc --go_out=plugins=grpc:. user.proto
protoc --go_out=. ./proto/*.proto

# 生成描述文件
protoc --go_out=./ ./proto/*.proto 
# 生成grpc描述文件
protoc --go-grpc_out=. ./proto/*.proto

# 也可以一起执行
protoc --go_out=. --go-grpc_out=. ./proto/*.proto
</code></pre>
<blockquote>
<p>开启go module 方式创建项目的时候，安装好的插件比如protoc-gen-go，可以使用go install 项目，的方式生成可执行文件到:$GROOT/bin下</p>
</blockquote>
<pre><code class="language-shell">go get google.golang.org/grpc
go get -u -v github.com/golang/protobuf/protoc-gen-go
go get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gorm1和Gorm2差异]]></title>
    <link href="jythons.github.io/16897602141334.html"/>
    <updated>2023-07-19T17:50:14+08:00</updated>
    <id>jythons.github.io/16897602141334.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<p><a href="https://blog.csdn.net/zzsan/article/details/120886965">https://blog.csdn.net/zzsan/article/details/120886965</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试宝典]]></title>
    <link href="jythons.github.io/16880312960537.html"/>
    <updated>2023-06-29T17:34:56+08:00</updated>
    <id>jythons.github.io/16880312960537.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true" href="#1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="octicon octicon-link"></span></a>1. 语言基础</h2>
<h3><a id="1-1-make%E5%92%8Cnew" class="anchor" aria-hidden="true" href="#1-1-make%E5%92%8Cnew"><span class="octicon octicon-link"></span></a>1.1 make和new</h3>
<p>make只能创建引用类型，例如：slice、map、channel，并且返回引用类型；并且在分配完内存空间后会初始化
new可以创建值类型，会为其赋初始值，返回指针类型，new分配的空间会被清零</p>
<h3><a id="1-2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true" href="#1-2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="octicon octicon-link"></span></a>1.2 字符串拼接方式</h3>
<ul>
<li>使用“+”拼接，str = str1+str2;</li>
<li>使用 sprintf 拼接，str = sprintf(&quot;%s%d%s&quot;, str1, 1, str2)</li>
<li>使用join拼接，s = []string{str1,str2}; str = strings.Join(s, &quot;&quot;);</li>
</ul>
<h3><a id="1-3%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true" href="#1-3%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="octicon octicon-link"></span></a>1.3 切片扩容机制</h3>
<p>切片底层使用数组实现，与数组共享同一块内存空间，当使用append方法向切片内追加元素时，如果容量不足，会发生扩容，扩容时，会先申请一块内存空间，然后将数据copy过去，再将新的元素追加到新的内存空间。申请的内存空间机制是，如果原来的切片容量小于1024，则新的内存空间为原来的2倍，如果原来的切片容量大于等于1024，则内存空间为原来的1.25倍。</p>
<h3><a id="1-4%E9%94%81%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true" href="#1-4%E9%94%81%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="octicon octicon-link"></span></a>1.4 锁有几种，都有什么特点</h3>
<h3><a id="1-5-gorutine%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8D%8F%E6%88%90%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%89" class="anchor" aria-hidden="true" href="#1-5-gorutine%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8D%8F%E6%88%90%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="octicon octicon-link"></span></a>1.5 gorutine运行机制（协成的实现机制）</h3>
<h2><a id="2-gin%E6%A1%86%E6%9E%B6" class="anchor" aria-hidden="true" href="#2-gin%E6%A1%86%E6%9E%B6"><span class="octicon octicon-link"></span></a>2. gin框架</h2>
<h3><a id="2-1%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true" href="#2-1%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0"><span class="octicon octicon-link"></span></a>2.1 路由实现</h3>
<h3><a id="2-2%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6" class="anchor" aria-hidden="true" href="#2-2%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="octicon octicon-link"></span></a>2.2 定义中间件</h3>
<h3><a id="2-3%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6" class="anchor" aria-hidden="true" href="#2-3%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="octicon octicon-link"></span></a>2.3 前置和后置中间件</h3>
<h2><a id="3-gorm" class="anchor" aria-hidden="true" href="#3-gorm"><span class="octicon octicon-link"></span></a>3. gorm</h2>
<h3><a id="3-1%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8-gorm%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true" href="#3-1%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8-gorm%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="octicon octicon-link"></span></a>3.1 怎样使用gorm连表查询</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[webpack打包electron应用本地环境搭建]]></title>
    <link href="jythons.github.io/16870507293577.html"/>
    <updated>2023-06-18T09:12:09+08:00</updated>
    <id>jythons.github.io/16870507293577.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="webpack%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true" href="#webpack%E9%85%8D%E7%BD%AE"><span class="octicon octicon-link"></span></a>webpack配置</h2>
<p>首先配置webpack打包target<br />
文档：<a href="https://webpack.docschina.org/configuration/target/">https://webpack.docschina.org/configuration/target/</a></p>
<pre><code>module.exports = {
  // electron 渲染应用
  target:'electron-renderer',
}
</code></pre>
<h2><a id="%E5%AE%89%E8%A3%85election%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true" href="#%E5%AE%89%E8%A3%85election%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="octicon octicon-link"></span></a>安装election运行环境</h2>
<pre><code class="language-bash"># Clone this repository
git clone https://github.com/electron/electron-quick-start
# Go into the repository
cd electron-quick-start
# Install dependencies
npm install
# Run the app
npm start
</code></pre>
<p>安装好electron运行环境后，需要修改一下main.js配置：</p>
<pre><code class="language-js">function createWindow () {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration: true,
      enableRemoteModule: true,
      contextIsolation: false
    }
  })

  // and load the index.html of the app.
  // mainWindow.loadFile('./dist/index.html')
  # 本地项目调试地址
  mainWindow.loadURL(&quot;http://localhost:8080&quot;);
  // Open the DevTools.
  mainWindow.webContents.openDevTools()
}
</code></pre>
<h2><a id="%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true" href="#%E9%97%AE%E9%A2%98"><span class="octicon octicon-link"></span></a>问题</h2>
<h3><a id="uncaught-referenceerror-exports-is-not-defined%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="anchor" aria-hidden="true" href="#uncaught-referenceerror-exports-is-not-defined%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="octicon octicon-link"></span></a>Uncaught ReferenceError: exports is not defined 解决办法</h3>
<p>这个问题是因为不支持ES6语法问题，需要将ES6转换成ES5。
转换方式：<a href="https://blog.csdn.net/weixin_43353035/article/details/126494522">https://blog.csdn.net/weixin_43353035/article/details/126494522</a></p>
<h3><a id="electron-require%E6%8A%A5%E9%94%99%EF%BC%9A-uncaught-referenceerror-require-is-not-defined" class="anchor" aria-hidden="true" href="#electron-require%E6%8A%A5%E9%94%99%EF%BC%9A-uncaught-referenceerror-require-is-not-defined"><span class="octicon octicon-link"></span></a>electron require()报错：Uncaught ReferenceError: require is not defined</h3>
<p>在election的main.js配置文件中加上这个配置即可：</p>
<pre><code>nodeIntegration: true, //渲染进程是否集成 Nodejs
contextIsolation: false,
enableRemoteModule: true //是否允许渲染进程使用远程模块
</code></pre>
<p>remote 使用：<a href="https://www.cnblogs.com/axl234/p/15206270.html">https://www.cnblogs.com/axl234/p/15206270.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次Vue+electron实现前端调用fs模块操作系统文件]]></title>
    <link href="jythons.github.io/16869017655372.html"/>
    <updated>2023-06-16T15:49:25+08:00</updated>
    <id>jythons.github.io/16869017655372.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="%E5%9C%A8vue%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BC%80%E5%90%AFnode%E6%94%AF%E6%8C%81" class="anchor" aria-hidden="true" href="#%E5%9C%A8vue%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BC%80%E5%90%AFnode%E6%94%AF%E6%8C%81"><span class="octicon octicon-link"></span></a>在VUE配置中开启node支持</h2>
<pre><code>vue.config.js

const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  pluginOptions:{
    electronBuilder:{
      nodeIntegration:true
    }
  }
})
</code></pre>
<pre><code>webpack.config.js

node: {
   fs: &quot;empty&quot;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang类型]]></title>
    <link href="jythons.github.io/16849850924438.html"/>
    <updated>2023-05-25T11:24:52+08:00</updated>
    <id>jythons.github.io/16849850924438.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="chan" class="anchor" aria-hidden="true" href="#chan"><span class="octicon octicon-link"></span></a>chan</h2>
<p>通道类型常用于协成之间的通信，底层采用一个环形队列的方式实现了一个缓冲区，数据传输过来，如果等待队列里没有读的gorutine, 会将数据暂存到缓存去，如果队列满了，需要写入的协成会放到待写入队列阻塞，如果有读的协成进来会先从缓冲区读取一个数据，缓存区由两个游标控制，一个游标记录环形队列下一次要读取的位置，另一个游标记录环形队列下一次要存放的位置。
环形队列使用切片数组实现。通过游标位置与容量的取模，计算下一个游标位置。</p>
<p>select用于读取或写入channel，如果没有default case，select读取数据没有读取到，会阻塞，有default case，则不会阻塞，如果是读取数据，要判断是否读取成功，关闭的通道也可以读取，select每次获取通道数据时，会将case切片打乱进行读取，防止有的case被饿死。</p>
<h2><a id="%E5%88%87%E7%89%87" class="anchor" aria-hidden="true" href="#%E5%88%87%E7%89%87"><span class="octicon octicon-link"></span></a>切片</h2>
<p>切片类型是基于数组的，但是比数组灵活，可以动态扩容，切片在扩容之前，与数组共用一块内存空间，所以修改切片内元素，也会变更数组的元素，如果切片发生扩容，则会从新开辟一块内存空间，然后将原切片的内容拷贝过去，新写入的元素会写到新的切片后面，这时修改切片内容，不会影响原数组。切片可以使用数组创建，也可以使用make创建。通过数组创建切片，切片的容量是start到数组结尾。使用copy复制切片不会发生扩容。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vue-element-admin 问题]]></title>
    <link href="jythons.github.io/16843986016050.html"/>
    <updated>2023-05-18T16:30:01+08:00</updated>
    <id>jythons.github.io/16843986016050.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="1%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5" class="anchor" aria-hidden="true" href="#1%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5"><span class="octicon octicon-link"></span></a>1.安装失败</h2>
<p>将python环境切换到2.X版本</p>
<h2><a id="2%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5" class="anchor" aria-hidden="true" href="#2%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5"><span class="octicon octicon-link"></span></a>2.启动失败</h2>
<p>1.克隆以后，删除package.json中tui-editor:1.3.3<br />
2.修改\src\components\MarkdownEditor\index.vue文件</p>
<p>将全部import换成下面几个</p>
<pre><code>import 'codemirror/lib/codemirror.css' 
import '@toast-ui/editor/dist/toastui-editor.css' 
import Editor from '@toast-ui/vue-editor' 
import defaultOptions from './default-options'  
</code></pre>
<p>并将该文件下的getValue和setValue分别换成getMarkdown和setMarkdown</p>
<p>3.单独安装tui-editor</p>
<pre><code>npm install --save @toast-ui/vue-editor
</code></pre>
<p>4.安装其他依赖</p>
<pre><code>npm i
</code></pre>
<p>5.跑起来</p>
<pre><code>npm run dev
</code></pre>
<blockquote>
<p>版权声明：本文为CSDN博主「阿莨去爬山了」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：<a href="https://blog.csdn.net/qq_44441509/article/details/128125578">https://blog.csdn.net/qq_44441509/article/details/128125578</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GIT项目添加多个远程分支]]></title>
    <link href="jythons.github.io/16843800406124.html"/>
    <updated>2023-05-18T11:20:40+08:00</updated>
    <id>jythons.github.io/16843800406124.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<ol>
<li>添加一个远程分支</li>
</ol>
<pre><code>git remote add [远程分支名称] 地址
git remote add in http://abc%40sina.com@git.com
</code></pre>
<blockquote>
<p>注意，这里如果是http的Git地址，需要在远程分支地址前加上用户名，如果用户名包含‘@’，需要转换成‘%40’</p>
</blockquote>
<ol start="2">
<li>删除远程分支</li>
</ol>
<pre><code>git remote remove [远程分支名称]
</code></pre>
<ol start="3">
<li>拉取代码和提交代码</li>
</ol>
<pre><code>git pull [远程分支名称] [分支]
git push [远程分支名称] [分支]
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vue post 下载文件]]></title>
    <link href="jythons.github.io/16823440770652.html"/>
    <updated>2023-04-24T21:47:57+08:00</updated>
    <id>jythons.github.io/16823440770652.html</id>
    <content type="html"><![CDATA[
<p>使用file-saver导出文件</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true" href="#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85"><span class="octicon octicon-link"></span></a>一、安装</h2>
<pre><code class="language-shell">npm install file-saver --save
# 如使用TS开发，可安装file-saver的TypeScript类型定义
npm install @types/file-saver --save-dev
</code></pre>
<h2><a id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8"><span class="octicon octicon-link"></span></a>二、使用</h2>
<pre><code class="language-js">import { saveAs } from 'file-saver'
// 保存文本
const blob = new Blob(['Hello, world!'])
saveAs(blob, 'hello world.txt')
// 预览图片
saveAs('https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png')
// 保存文件
const blob = new Blob([fileStream])// fileStream 是文件流，一般从后台获取
saveAs(blob, fileName)// fileName 保存文件的名称，需要带后缀
</code></pre>
<h2><a id="%E4%B8%89%E3%80%81%E9%80%9A%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true" href="#%E4%B8%89%E3%80%81%E9%80%9A%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="octicon octicon-link"></span></a>三、通用场景</h2>
<p>一般开发过程中，需要下载本地文件，或者从服务器下载文件，可使用下面封装的方法。</p>
<h3><a id="%E4%B8%8B%E8%BD%BD%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true" href="#%E4%B8%8B%E8%BD%BD%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6"><span class="octicon octicon-link"></span></a>下载本地文件</h3>
<pre><code class="language-js">	// file.js 封装下载本地文件方法
	import axios from 'axios'
	import { saveAs } from 'file-saver'
	/**
	 * @params {string} localFileName 本地文件名称
	 * @params {string} saveFileName 下载的文件名称
	 * @retuen {promise}
	 */
	export const downloadLocalFile = (localFileName, saveFileName) =&gt; {
	    return new Promise((resolve, reject) =&gt; {
	        axios({
	            url: `/file/${localFileName}`,	// 本地文件夹路径+本地文件名称(若资源在服务器，且是具体的路径，这里可改成该资源路径，此时封装的方法需要微调，入参的localFileName改成资源路径resource)
	            method: 'get',					
	            responseType: 'blob',			//	arraybuffer	也可
	        }).then(res =&gt; {
	            const blob = new Blob([res.data])
	            if (navigator.msSaveBlob) {			// 兼容IE
	                navigator.msSaveBlob(blob, saveFileName)
	            } else {
	                const url = window.URL.createObjectURL(blob)
	                saveAs(url, saveFileName)
	            }
	            resolve()
	        }).catch(err =&gt; {
	        	// 这里可以统一处理错误，比如&quot;未找到相关文件&quot;，&quot;下载失败&quot;等
	        	if (err.message === 'Request failed with status code 404') {
	        		// 提示or弹框：未找到相关文件
	        	} else {
	        		// 提示or弹框：下载失败
	        	}
	            reject(err)
	        })
	    })
	}

	// 使用（注意文件格式的后缀名）
	downloadLocalFile('excelFile.xlsx', 'newExcelFile.xlsx').then(res =&gt; {
		// 下载成功后的操作
		console.log('下载成功！')
	})

</code></pre>
<h3><a id="%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%89" class="anchor" aria-hidden="true" href="#%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%89"><span class="octicon octicon-link"></span></a>下载服务器文件（服务器返回文件流）</h3>
<pre><code class="language-js">	// file.js 封装下载本地文件方法
	import axios from 'axios'
	import { saveAs } from 'file-saver'
	/**
	 * @params {stream} fileStream 服务器返回的文件流
	 * @params {string} saveFileName 下载的文件名称
	 * @retuen {promise}
	 */
	 export const downloadFile = (fileStream, saveFileName) =&gt; {
		return new Promise((resolve, reject) =&gt; {
	 		const blob = new Blob([fileStream])
	 		if (navigator.msSaveBlob) {			// 兼容IE
	        	navigator.msSaveBlob(blob, saveFileName)
	       	} else {
	      		const url = window.URL.createObjectURL(blob)
	       		saveAs(url, saveFileName)
	       	}
	     	resolve()
	 	}) 
	 }
	 
	// 使用（注意文件格式的后缀名）
	const fileStream = await xxApi()  // 请求后台接口，获取文件流
	downloadFile(fileStream, 'file.pdf').then(res =&gt; {
		// 下载成功后的操作
		console.log('下载成功！')
	})

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 时间问题]]></title>
    <link href="jythons.github.io/16802311282072.html"/>
    <updated>2023-03-31T10:52:08+08:00</updated>
    <id>jythons.github.io/16802311282072.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E5%8C%BA" class="anchor" aria-hidden="true" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E5%8C%BA"><span class="octicon octicon-link"></span></a>查看当前数据库时区</h2>
<pre><code>show variables like '%time_zone%';
</code></pre>
<h2><a id="%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA" class="anchor" aria-hidden="true" href="#%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA"><span class="octicon octicon-link"></span></a>修改时区</h2>
<h3><a id="%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9"><span class="octicon octicon-link"></span></a>命令行修改</h3>
<pre><code>set global time_zone = '+8:00';
flush privileges;
</code></pre>
<h3><a id="%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6etcmy-cnf" class="anchor" aria-hidden="true" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6etcmy-cnf"><span class="octicon octicon-link"></span></a>修改配置文件 /etc/my.cnf</h3>
<pre><code>[mysqld]
default-time_zone = '+8:00'
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jre环境安装]]></title>
    <link href="jythons.github.io/16800068545472.html"/>
    <updated>2023-03-28T20:34:14+08:00</updated>
    <id>jythons.github.io/16800068545472.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="0%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true" href="#0%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="octicon octicon-link"></span></a>0.版本说明</h2>
<p>环境：centos7.9<br />
版本：server-jre-8u311</p>
<h2><a id="1%E4%B8%8B%E8%BD%BD-jre" class="anchor" aria-hidden="true" href="#1%E4%B8%8B%E8%BD%BD-jre"><span class="octicon octicon-link"></span></a>1.下载JRE</h2>
<p>官网下载地址<br />
注意：我们下载的是server jre而不是jre，我下载的版本号如下：<br />
server-jre-8u311-linux-x64.tar.gz</p>
<h2><a id="2%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true" href="#2%E5%AE%89%E8%A3%85"><span class="octicon octicon-link"></span></a>2.安装</h2>
<p>解压安装包<br />
将安装包上传到/opt/software目录下，进行解压</p>
<pre><code>[root@localhost /]# cd /opt/software
[root@localhost /]# tar -xzvf server-jre-8u311-linux-x64.tar.gz
</code></pre>
<p>安装目录(/opt/java/)
/opt/java/不存在的话，在opt文件夹下新建java目录</p>
<pre><code>[root@localhost /]# mkdir -p /opt/java/
</code></pre>
<p>将解压的文件夹移动到安装目录(/opt/java/)下</p>
<pre><code>[root@localhost /]# mv /opt/software/jdk1.8.0_311 /opt/java/
</code></pre>
<h2><a id="3%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true" href="#3%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE"><span class="octicon octicon-link"></span></a>3.权限设置</h2>
<p>java目录以及子目录授予root权限</p>
<pre><code>[root@localhost /]# chown root:root -R /opt/java/jdk1.8.0_311/
</code></pre>
<h2><a id="4%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true" href="#4%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="octicon octicon-link"></span></a>4.配置环境变量</h2>
<p>编辑环境变量配置文件 /etc/profile</p>
<pre><code>[root@localhost /]# vi /etc/profile 
</code></pre>
<p>在文件末尾加入下面代码</p>
<pre><code>export JAVA_HOME=/opt/java
export JRE_HOME=/opt/java/jdk1.8.0_311
export CLASSPATH=$JRE_HOME/lib/rt.jar:$JRE_HOME/lib/ext
export PATH=$PATH:$JRE_HOME/bin
</code></pre>
<p>使环境变量即时生效</p>
<pre><code>[root@localhost /]# source /etc/profile
</code></pre>
<h2><a id="5%E6%9F%A5%E7%9C%8B-java%E7%89%88%E6%9C%AC%E5%8F%B7" class="anchor" aria-hidden="true" href="#5%E6%9F%A5%E7%9C%8B-java%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="octicon octicon-link"></span></a>5.查看java版本号</h2>
<pre><code>[root@localhost /]# java -version
java version &quot;1.8.0_311&quot;
Java(TM) SE Runtime Environment (build 1.8.0_311-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.311-b11, mixed mode)
</code></pre>
<p>出现以上结果，则表示安装成功</p>
<h2><a id="6%E8%BF%90%E8%A1%8C-jar%E5%8C%85" class="anchor" aria-hidden="true" href="#6%E8%BF%90%E8%A1%8C-jar%E5%8C%85"><span class="octicon octicon-link"></span></a>6.运行jar包</h2>
<pre><code class="language-java">java -jar ConsulProducter-0.0.1-SNAPSHOT.jar --spring.profiles.active=p2 2&gt;&amp;1 &amp;
</code></pre>
<h2><a id="7%E7%BB%93%E6%9D%9F%E8%AF%AD" class="anchor" aria-hidden="true" href="#7%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="octicon octicon-link"></span></a>7.结束语</h2>
<p>运行程序需要jre，开发才需要jdk，但在服务器上我们只需要jre运行程序即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP数组实现原理]]></title>
    <link href="jythons.github.io/16794574627172.html"/>
    <updated>2023-03-22T11:57:42+08:00</updated>
    <id>jythons.github.io/16794574627172.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<p>在 PHP 中，数组实际上是一个有序映射表（ordered map），也就是关联数组（associative array）或哈希表（hash table）。它可以用于存储键值对，其中每个键都必须是唯一的。PHP 数组的底层实现是使用了哈希表，哈希表是一种基于数组的数据结构，它可以快速地查找和插入数据。</p>
<p>哈希表的实现原理是把每个键映射到一个索引（index）上，这个索引就是数组的下标。具体的实现过程是，在插入一个键值对时，PHP 会先根据键计算出它的哈希值，然后再根据哈希值计算出它的索引位置。如果该索引位置已经存在其他键值对，就会发生哈希冲突（hash collision），这时候 PHP 会使用开放地址法（open addressing）或链式法（chaining）解决冲突。</p>
<p>在 PHP 中，数组可以使用下标访问元素，也可以使用 foreach 循环遍历元素。当使用下标访问元素时，PHP 会先计算出下标的哈希值，然后根据哈希值查找对应的索引位置，最后返回该位置上的值。当使用 foreach 循环遍历元素时，PHP 会按照键的顺序遍历数组，从而实现有序性。</p>
<p>总之，PHP 数组底层实现原理是使用哈希表，它支持快速的查找和插入操作，并且可以按照键的顺序遍历元素。</p>
<h2><a id="%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95" class="anchor" aria-hidden="true" href="#%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="octicon octicon-link"></span></a>开放地址法</h2>
<p>开放地址法（open addressing）是一种解决哈希冲突的方法，它是在哈希表中寻找空闲的位置来插入冲突的元素。当哈希表中的某个位置已经被占用时，开放地址法会在哈希表中寻找下一个空闲的位置，直到找到一个空闲位置为止。具体的寻找空闲位置的方法有以下几种：</p>
<p>线性探测（linear probing）：从冲突的位置开始，依次往后查找直到找到一个空闲位置为止。</p>
<p>二次探测（quadratic probing）：从冲突的位置开始，依次往后查找直到找到一个空闲位置为止，每次查找的步长是一个二次函数。</p>
<p>双重哈希（double hashing）：使用两个哈希函数来计算索引位置，如果第一个哈希函数计算出的位置已经被占用，就使用第二个哈希函数继续计算位置。</p>
<p>开放地址法的优点是能够充分利用哈希表中的空闲位置，减少冲突的概率，从而提高哈希表的性能。缺点是当哈希表中的空闲位置不足时，插入元素的时间复杂度会变得很高，并且需要保证哈希表的容量大于等于元素的数量。</p>
<h2><a id="%E9%93%BE%E5%BC%8F%E6%B3%95" class="anchor" aria-hidden="true" href="#%E9%93%BE%E5%BC%8F%E6%B3%95"><span class="octicon octicon-link"></span></a>链式法</h2>
<p>链式法（chaining）是一种解决哈希冲突的方法，它是在哈希表中每个位置上维护一个链表，将所有哈希值相同的元素都存储在同一个链表中。当发生哈希冲突时，新元素会被插入到对应位置的链表中，而不是覆盖原来的元素。</p>
<p>链式法的优点是可以解决哈希冲突，并且不需要像开放地址法一样保证哈希表的容量大于等于元素的数量。缺点是当链表长度过长时，会影响哈希表的性能，因为查找元素需要遍历整个链表。为了避免这种情况，通常会在链表长度超过一定阈值时，将链表转换为更高效的数据结构，如红黑树。</p>
<p>链式法的实现方式是，在哈希表中维护一个数组，数组的每个元素都是一个链表的头节点。当插入元素时，先计算出元素的哈希值，然后根据哈希值找到对应位置的链表头节点，将元素插入到链表中。当查找元素时，也是先计算出元素的哈希值，然后根据哈希值找到对应位置的链表头节点，遍历链表查找元素。</p>
<p>总之，链式法是一种解决哈希冲突的方法，它可以将哈希值相同的元素存储在同一个链表中，并且不需要保证哈希表的容量大于等于元素的数量。但是当链表长度过长时，会影响哈希表的性能。</p>
<h2><a id="php%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" class="anchor" aria-hidden="true" href="#php%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="octicon octicon-link"></span></a>PHP解决哈希冲突</h2>
<p>PHP数组使用的是链式法来解决哈希冲突。在哈希表中，如果两个或多个键具有相同的哈希值，则它们被称为哈希冲突。链式法是一种解决哈希冲突的方法，它通过在哈希表中使用链表来存储具有相同哈希值的键。当哈希冲突发生时，新的键值对被添加到链表的末尾。这种方法在PHP中被广泛使用，因为它可以处理大量的数据，并且具有高效的插入和查找操作。开发地址法是另一种解决哈希冲突的方法，它通过在哈希表中查找下一个可用的空槽来存储具有相同哈希值的键。然而，开发地址法在处理大量的数据时可能会导致性能下降。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度学习之多层感知器]]></title>
    <link href="jythons.github.io/16789745026753.html"/>
    <updated>2023-03-16T21:48:22+08:00</updated>
    <id>jythons.github.io/16789745026753.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h2><a id="1%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true" href="#1%E6%A6%82%E5%BF%B5"><span class="octicon octicon-link"></span></a>1.概念</h2>
<p>多层感知器（Multilayer Perceptron，MLP）是一种常见的人工神经网络模型，也是最早被广泛应用的神经网络模型之一。它由输入层、若干个隐藏层和一个输出层组成，其中每个层都由多个神经元组成。每个神经元接收来自前一层的输入，并通过激活函数将这些输入加权求和，得到自己的输出。多层感知器通过反向传播算法来训练，使得其输出能够与训练集中的目标输出尽可能接近，从而实现分类、回归等任务。多层感知器具有较强的非线性建模能力，可以处理复杂的非线性问题。</p>
<!-- more -->
<h2><a id="2%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true" href="#2%E5%8E%9F%E7%90%86"><span class="octicon octicon-link"></span></a>2.原理</h2>
<p>多层感知器的实现原理是基于神经元之间的连接和权重的调整。在多层感知器中，神经元之间的连接形成了一个有向图，其中每条边表示两个神经元之间的连接。每个神经元都有一个输出值，该值是由它的输入值和权重值的加权和经过激活函数计算得出的。</p>
<p>在训练过程中，多层感知器通过反向传播算法来更新神经元之间的权重，从而使得模型能够更好地拟合训练数据。具体地，反向传播算法将误差从输出层向输入层逐层传递，通过链式法则计算每个神经元对误差的贡献，并根据这些贡献来更新权重值。</p>
<ol>
<li>
<p>多层感知器的实现过程可以分为以下几个步骤：</p>
</li>
<li>
<p>初始化网络参数，包括权重和偏置值。</p>
</li>
<li>
<p>通过前向传播计算网络的输出值。</p>
</li>
<li>
<p>计算输出层的误差，并通过反向传播逐层计算每个神经元对误差的贡献。</p>
</li>
<li>
<p>根据贡献值更新网络的权重和偏置值。</p>
</li>
</ol>
<p>重复上述步骤直至达到收敛条件。</p>
<p>通过这些步骤，多层感知器可以逐步优化网络的参数，提高模型的准确性和泛化能力。</p>
<h2><a id="3%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true" href="#3%E4%BE%8B%E5%AD%90"><span class="octicon octicon-link"></span></a>3.例子</h2>
<p>假设我们要用多层感知器来解决一个二元分类问题，即根据两个特征值 \(x_1\)和\(x_2\)
​​  来判断一个样本属于哪个类别（0 或 1）。我们可以构建一个包含一个隐藏层的多层感知器，其中隐藏层包含 3 个神经元，输出层包含一个神经元。</p>
<p>首先，我们需要对多层感知器进行初始化。假设我们将所有的权重和偏置值都初始化为随机值。</p>
<p>接下来，我们通过前向传播计算网络的输出值。假设输入样本的特征值为\(x_1=0.5\)
和\(x_2=0.8\)，我们可以计算出隐藏层每个神经元的输出值：</p>
\[h_1 = \sigma(w_{11}x_1+w_{21}x_2+b_1) \\ h_2 = \sigma(w_{12}x_1+w_{22}x_2+b_1) \\ h_3 = \sigma(w_{13}x_1+w_{23}x_2+b_1)
\]
<p>其中 σ 是激活函数，比如 sigmoid 函数。我们可以选择不同的激活函数来实现不同的非线性变换。</p>
<p>然后，我们可以通过前向传播计算输出层的值：</p>
\[o=\sigma(w_1*h_1+w_2*h_2+w_3*h_3+b_2)
\]
<p>最后，我们可以根据输出层的值来判断样本属于哪个类别。比如，如果 \(\sigma&gt;0.5\)，我们可以将样本归为类别 1，否则归为类别 0。</p>
<p>在训练过程中，我们需要通过反向传播算法来更新神经元之间的权重和偏置值，从而使得模型能够更好地拟合训练数据。具体地，我们可以计算输出层的误差，然后逐层计算每个神经元对误差的贡献，并根据这些贡献来更新权重值。最终，我们可以得到一个准确率较高的多层感知器模型，用于对新的样本进行分类。</p>
<h2><a id="4-keras" class="anchor" aria-hidden="true" href="#4-keras"><span class="octicon octicon-link"></span></a>4.Keras</h2>
<p>Keras是一个用Python编写的用于神经网络开发的应用接口，调用接口可以实现神经网络、卷积神经网络、循环神经网络等常用深度学习算法的开发。</p>
<h3><a id="4-1%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true" href="#4-1%E7%89%B9%E7%82%B9"><span class="octicon octicon-link"></span></a>4.1 特点</h3>
<ul>
<li>集成了深度学习中各类成熟的算法，容易安装和使用，样例丰富，教程和文档也非常详细</li>
<li>能够已TensorFlow，或者Theano作为后端运行</li>
</ul>
<blockquote>
<p>地址：<a href="https://keras.io/zh/">https://keras.io/zh/</a>  或  <a href="https://keras.io/">https://keras.io/</a></p>
</blockquote>
<blockquote>
<p>30s上手Keras：<a href="https://keras-cn.readthedocs.io/en/latest/#30skeras">https://keras-cn.readthedocs.io/en/latest/#30skeras</a></p>
</blockquote>
<h3><a id="4-2-keras-or-tensorflow" class="anchor" aria-hidden="true" href="#4-2-keras-or-tensorflow"><span class="octicon octicon-link"></span></a>4.2 Keras or Tensorflow</h3>
<p>TensorFlow是一个采用数据流图，用于数值计算的开源软件库，可自动计算模型相关的微分导数：非常适合用于神经网络模型的求解。</p>
<p>Keras可看作为tensorflow封装后的一个接口（Keras作为前端，TensorFlow作为后端）。Keras为用户提供了一个易于交互的外壳，方便进行深度学习的快速开发。</p>
<h3><a id="4-3-keras%E5%BB%BA%E7%AB%8Bmlp%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true" href="#4-3-keras%E5%BB%BA%E7%AB%8Bmlp%E6%A8%A1%E5%9E%8B"><span class="octicon octicon-link"></span></a>4.3 Keras建立MLP模型</h3>
<pre><code class="language-python"># 建立一个Sequential顺序模型
from keras.models import Sequential
model = Sequential()

# 通过.add()叠加隔层网络
from keras.layers import Dense
model.add(Dense(units=3, activation='sigmoid', input_dim=3))
model.add(Dense(units=1, activation='sigmoid'))

# 通过.compile()配置模型求解过程参数
model.compile(loss='categorical_crossentropy', optimizer='sgd')

# 训练模型,epochs 迭代多少次
model.fit(x_train, y_train, epochs=5)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模型优化]]></title>
    <link href="jythons.github.io/16787167786323.html"/>
    <updated>2023-03-13T22:12:58+08:00</updated>
    <id>jythons.github.io/16787167786323.html</id>
    <content type="html"><![CDATA[
<!--more-->
<h2><a id="%E6%95%B0%E6%8D%AE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7" class="anchor" aria-hidden="true" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="octicon octicon-link"></span></a>数据的重要性</h2>
<p>数据质量决定模型表现的上限！<br />
<strong>Always check:</strong></p>
<ol>
<li>数据属性的意义，是否为无关数据</li>
<li>不同属性数据的数量级差异性如何</li>
<li>是否有异常数据</li>
<li>采集数据的方法是否合理，采集到的数据是否有代表性</li>
<li>对于标签结果，要确保标签判定规则的一致性（统一标准）</li>
</ol>
<p><img src="media/16787167786323/WX20230313-222300.png" alt="WX20230313-222300" /></p>
<h2><a id="%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true" href="#%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="octicon octicon-link"></span></a>模型优化方法</h2>
<ul>
<li>遍历核心参数组合，评估对应模型表现（比如：逻辑回归边界函数考虑多项式，KNN尝试不同的n_neighbors值）</li>
<li>扩大数据样本</li>
<li>增加或减少数据属性</li>
<li>对数据进行降维处理</li>
<li>对模型进行正则化处理，调整正则项\(\lambda\)的数值</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据分离与混淆矩阵]]></title>
    <link href="jythons.github.io/16787140765765.html"/>
    <updated>2023-03-13T21:27:56+08:00</updated>
    <id>jythons.github.io/16787140765765.html</id>
    <content type="html"><![CDATA[
<!--more-->
<h2><a id="%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB" class="anchor" aria-hidden="true" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="octicon octicon-link"></span></a>数据分离</h2>
<h3><a id="%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%AF%84%E4%BC%B0%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true" href="#%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%AF%84%E4%BC%B0%E6%B5%81%E7%A8%8B"><span class="octicon octicon-link"></span></a>模型训练与评估流程</h3>
<pre><code class="language-mermaid">sequenceDiagram
participant 数据载入
participant 数据可视化预处理
participant 模型创建
participant 全数据用于模型训练
participant 模型评估

数据载入-&gt;&gt;数据可视化预处理: 
数据可视化预处理-&gt;&gt;模型创建: 
模型创建-&gt;&gt;全数据用于模型训练: 
全数据用于模型训练-&gt;&gt;模型评估: 
</code></pre>
<blockquote>
<p>没有新数据用于评估模型表现怎么办？</p>
</blockquote>
<p>对全数据进行数据分离，部分用于训练，部分用于新数据的结果预测。</p>
<h3><a id="%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true" href="#%E6%B5%81%E7%A8%8B"><span class="octicon octicon-link"></span></a>流程</h3>
<ol>
<li>把数据分成两部分：训练集、测试集</li>
<li>使用训练集数据进行模型训练</li>
<li>使用测试集数据进行预测，更有效的评估模型对于新数据的预测表现。</li>
</ol>
<h3><a id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98" class="anchor" aria-hidden="true" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98"><span class="octicon octicon-link"></span></a>代码实战</h3>
<pre><code class="language-python">from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test = train_test_split(X,y,random_state=4,test_size=0.4)
</code></pre>
<h2><a id="%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%EF%BC%88confusion-matrix%EF%BC%89" class="anchor" aria-hidden="true" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%EF%BC%88confusion-matrix%EF%BC%89"><span class="octicon octicon-link"></span></a>混淆矩阵（Confusion Matrix）</h2>
<p><strong>概念：</strong> 混淆矩阵，又称为误差矩阵，用于衡量分类算法的准确程度。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>预测结果</th>
<th>预测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>实际结果</td>
<td>0</td>
<td>True Negative(TN)</td>
<td>False Positive(FP)</td>
</tr>
<tr>
<td>实际结果</td>
<td>1</td>
<td>False Negative(FN)</td>
<td>True Positive(TP)</td>
</tr>
</tbody>
</table>
<ul>
<li>True Negative(TN)：预测准确，实际为负样本的数量（实际0，预测0）</li>
<li>True Positive(TP)：预测准确，实际为正样本的数量（实际1，预测1）</li>
<li>False Positive(FP)：预测错误，实际为负样本的数量（实际0，预测1）</li>
<li>False Negative(FN)：预测错误，实际为正样本的数量（实际1，预测0）</li>
</ul>
<h3><a id="%E5%87%86%E7%A1%AE%E7%8E%87%E8%AF%84%E4%BC%B0%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true" href="#%E5%87%86%E7%A1%AE%E7%8E%87%E8%AF%84%E4%BC%B0%E9%97%AE%E9%A2%98"><span class="octicon octicon-link"></span></a>准确率评估问题</h3>
<p>分类任务中，计算测试数据集预测准确率（accuracy）以评估模型表现<br />
局限性：无法真实反映模型针对各个分类的预测准确度</p>
<h5><a id="%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true" href="#%E4%B8%BE%E4%BE%8B"><span class="octicon octicon-link"></span></a>举例</h5>
<p>假如有如下一千个数据：数据中有900个1，和100个0，预测是0或1<br />
模型1：预测出850个1预测正确，50个0预测正确，正确率90%<br />
模型2：预测所有的样本结果都是1，准确率90%（空准确率）</p>
<blockquote>
<p>准确率可以方便的用于衡量模型的整体预测效果，但无法反映细节信息，具体表现在：</p>
<ul>
<li>没有体现数据预测的<strong>实际分布情况</strong>（0、1本身的分布比例）</li>
<li>没有体现模型<strong>错误预测的类型</strong></li>
</ul>
</blockquote>
<h3><a id="%E6%9B%B4%E5%A4%9A%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87" class="anchor" aria-hidden="true" href="#%E6%9B%B4%E5%A4%9A%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87"><span class="octicon octicon-link"></span></a>更多模型评估指标</h3>
<p>通过混淆矩阵，计算更丰富的模型评估指标
<img src="media/16787140765765/WX20230313-215845.png" alt="WX20230313-215845" /></p>
<h3><a id="%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E6%8C%87%E6%A0%87%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E6%8C%87%E6%A0%87%E7%89%B9%E7%82%B9"><span class="octicon octicon-link"></span></a>混淆矩阵指标特点</h3>
<ul>
<li>分类任务中，相比单一的预测准确率，混淆矩阵提供了更全面的模型评估信息</li>
<li>通过混淆矩阵，我们可以计算出多样的模型表现衡量指标，从而更好地选择模型</li>
</ul>
<h4><a id="%E5%93%AA%E4%B8%AA%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87%E6%9B%B4%E5%85%B3%E9%94%AE%EF%BC%9F" class="anchor" aria-hidden="true" href="#%E5%93%AA%E4%B8%AA%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87%E6%9B%B4%E5%85%B3%E9%94%AE%EF%BC%9F"><span class="octicon octicon-link"></span></a>哪个衡量指标更关键？</h4>
<ul>
<li>衡量指标的选择取决于应用场景</li>
<li>垃圾邮件检测（正样本为“垃圾邮件”）：希望普通邮件（负样本）不要被判断为垃圾邮件（正样本），即：判断为垃圾邮件的样本都是判断正确的，需要管局精确率，还希望所有的垃圾邮件尽可能被判断出来，需要关注召回率</li>
<li>异常交易检测（正样本为“异常交易”）：希望判断为正常的交易（负样本）中尽可能不存在异常交易，还需要关注特异度</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[过拟合和欠拟合]]></title>
    <link href="jythons.github.io/16781100210039.html"/>
    <updated>2023-03-06T21:40:21+08:00</updated>
    <id>jythons.github.io/16781100210039.html</id>
    <content type="html"><![CDATA[
<p>概念：模型不合适，导致其无法对数据实现有效预测。</p>
<span id="more"></span><!-- more -->
<table>
<thead>
<tr>
<th></th>
<th>训练数据</th>
<th>预测数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>欠拟合</td>
<td>不准确</td>
<td>不准确</td>
</tr>
<tr>
<td>过拟合</td>
<td>准确</td>
<td>不准确</td>
</tr>
<tr>
<td>好模型</td>
<td>准确</td>
<td>准确</td>
</tr>
</tbody>
</table>
<!-- more -->
<h2><a id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98"><span class="octicon octicon-link"></span></a>如何解决过拟合问题</h2>
<h3><a id="%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true" href="#%E5%8E%9F%E5%9B%A0"><span class="octicon octicon-link"></span></a>原因</h3>
<ul>
<li>模型结构复杂（维度过高）</li>
<li>使用了过多属性，模型训练时包含了干扰项信息</li>
</ul>
<h3><a id="%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" class="anchor" aria-hidden="true" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="octicon octicon-link"></span></a>解决办法</h3>
<ul>
<li>简化模型结构（使用低阶模型，比如线性模型）</li>
<li>数据预处理，保留主成分信息（数据PCA处理）</li>
<li>在模型训练时，增加正则化项</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[决策树]]></title>
    <link href="jythons.github.io/16771618333656.html"/>
    <updated>2023-02-23T22:17:13+08:00</updated>
    <id>jythons.github.io/16771618333656.html</id>
    <content type="html"><![CDATA[
<p>一种对实例进行<strong>分类</strong>的<strong>树形结构</strong>，通过<strong>多层判断</strong>区分目标所属类别。<br />
本质：通过多层判断，从训练数据集中归纳出一组分类规则。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true" href="#%E4%BC%98%E7%82%B9"><span class="octicon octicon-link"></span></a>优点</h2>
<ul>
<li>计算量小，运算速度快</li>
<li>易于理解，可清晰查看各属性的重要性</li>
</ul>
<h2><a id="%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true" href="#%E7%BC%BA%E7%82%B9"><span class="octicon octicon-link"></span></a>缺点</h2>
<ul>
<li>忽略属性间的相关性</li>
<li>样本类别分布不均匀时，容易影响模型表现</li>
</ul>
<blockquote>
<p>属性间相关性是指，两个属性之间如果有关联，该模型会忽略其中的相关性。<br />
样本分布不均匀，指的是某一个样本数量比较多。</p>
</blockquote>
<h2><a id="%E5%86%B3%E7%AD%96%E6%A0%91%E6%B1%82%E8%A7%A3" class="anchor" aria-hidden="true" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E6%B1%82%E8%A7%A3"><span class="octicon octicon-link"></span></a>决策树求解</h2>
<p>假设给定训练数据集</p>
\[D = \{(x_1, y_1), (x_2, y_2),...,(x_n, y_n)\}
\]
<p>其中，</p>
\[x_i = (x_i^{(1)},x_i^{(2)},...,x_i^{(m)})^T
\]
<p>为输入实例, m为特征个数，</p>
\[y_i \in \{1,2,3,...,K\}
\]
<p>为类标记，</p>
\[i = 1,2,...,N
\]
<p>N为样本容量。</p>
<blockquote>
<p>目标：根据训练数据集构建一个<strong>决策树模型</strong>，使它能够对实例进行正确的分类。<br />
问题核心：特征选择，每一个节点，应该选用哪个特征。</p>
</blockquote>
<h3><a id="%E4%B8%89%E7%A7%8D%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true" href="#%E4%B8%89%E7%A7%8D%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="octicon octicon-link"></span></a>三种求解方法</h3>
<p>ID3、C4.5、CART</p>
<blockquote>
<p>参考资料：<br />
1.<a href="https://www.jianshu.com/p/af7fd132de30">https://www.jianshu.com/p/af7fd132de30</a><br />
2.<a href="https://www.cnblogs.com/callyblog/p/9724823.html">https://www.cnblogs.com/callyblog/p/9724823.html</a></p>
</blockquote>
<h4><a id="id3" class="anchor" aria-hidden="true" href="#id3"><span class="octicon octicon-link"></span></a>ID3</h4>
<p>利用信息熵原理选择信息增益最大的属性作为分类属性，递归的拓展决策树的分支，完成决策树的构造。<br />
信息熵（entropy）是度量随机变量不确定性的指标，熵越大，变量的不确定性就越大。假定当前样本集合D中第k类样本所占的比例为\(p_k\)，则D的信息熵为：</p>
\[Ent(D) = -\sum_{k=1}^{|y|}{p_klog_2P_k}
\]
<p>Ent(D)的值越小，变量的不确定性越小。</p>
\[p_k = 1 时：  
Ent(D) = 0
\]
<p>根据信息熵，可以计算以属性a进行样本划分带来的信息增益：</p>
\[Gain(D,a) = Ent(D) - \sum_{v=1}^V{D^v\over D}Ent(D^v)
\]
<p>V为根据属性a划分出的类别数，D为当前样本总数，\(D^v\)为类别v样本数。</p>
<p>\(Ent(D)\): 划分前的信息熵</p>
<p>\(\sum_{v=1}^V{D^v\over D}Ent(D^v)\)：划分后的信息熵</p>
<blockquote>
<p>目标：<strong>划分后样本分布不确定性尽可能小</strong>，即划分后信息熵小，信息增益大</p>
</blockquote>
<p>示例：<br />
<img src="media/16771618333656/WX20230223-230415.png" alt="WX20230223-230415" /></p>
<blockquote>
<p>选择信息增益最大的属性作为第一个节点。</p>
</blockquote>
<p>模型计算出来的结果：
<img src="media/16771618333656/WX20230223-230513.png" alt="WX20230223-230513" /></p>
<h2><a id="%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B" class="anchor" aria-hidden="true" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="octicon octicon-link"></span></a>异常检测</h2>
<p>概念：根据输入数据，对不符合预期模式的数据进行识别。</p>
<h3><a id="%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6" class="anchor" aria-hidden="true" href="#%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6"><span class="octicon octicon-link"></span></a>概率密度</h3>
<p>概念：概率密度函数是一个描述随机变量在某个确定的取值点附近的可能性的函数。</p>
<h4><a id="%E5%85%AC%E5%BC%8F" class="anchor" aria-hidden="true" href="#%E5%85%AC%E5%BC%8F"><span class="octicon octicon-link"></span></a>公式</h4>
<p>区间\((x_1, x_2)\)的概率为：</p>
\[P(x_1, x_2) = \int_{x_1}^{x_2}{p(x)dx}
\]
<blockquote>
<p>\(p(x)\)是概率密度</p>
</blockquote>
<h4><a id="%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83" class="anchor" aria-hidden="true" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="octicon octicon-link"></span></a>高斯分布</h4>
<p>高斯分布的概率密度函数是：</p>
\[p(x) = {1\over\delta\sqrt 2\pi}e^{-(x-\mu)^2\over 2\delta^2}
\]
<blockquote>
<p>其中，\(\mu\)为数据均值，\(\delta\)为标准差</p>
</blockquote>
\[\mu = {1\over m}\sum_{i=1}^mx^{(i)}
\]
\[\delta^2 = {1\over m}\sum_{i=1}^m{(x^{(i)}-\mu)^2}
\]
<p>当数据维度高于一维：</p>
\[\begin{pmatrix}
x_1^{(1)},&amp;x_1^{(2)},&amp;...&amp;x_1^{(m)}\\
x_n^{(1)},&amp;x_n^{(2)},&amp;...&amp;x_n^{(m)}\\
\end{pmatrix}
\]
<p>1、计算数据均值\(\mu_1,\mu_2,...\mu_n,\)，标准差\(\delta_1,\delta_1,...,\delta_n\)</p>
\[\mu_j = {1\over m}\sum_{i=1}^mx_j^{(i)}
\]
\[\delta_j^2 = {1\over m}\sum_{i=1}^m{(x_j^{(i)}-\mu_j)^2}
\]
<p>2、计算概率密度函数\(p(x)\):</p>
\[p(x) = \prod_{j=1}^{n}p(x_j;\mu_j,\delta_j^2) = \prod_{j=1}^{n}{1\over \delta_j\sqrt 2\pi}e^{-{(x_j-\mu_j)^2\over 2\delta_j^2}}
\]
<blockquote>
<p>判断\(p(x)\)是否大于阈值，小于阈值，标识该点为异常点。</p>
</blockquote>
<h2><a id="%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%EF%BC%88pca%EF%BC%89" class="anchor" aria-hidden="true" href="#%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%EF%BC%88pca%EF%BC%89"><span class="octicon octicon-link"></span></a>主成分分析（PCA）</h2>
<h3><a id="%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%EF%BC%88dimensionality-reduction%EF%BC%89" class="anchor" aria-hidden="true" href="#%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%EF%BC%88dimensionality-reduction%EF%BC%89"><span class="octicon octicon-link"></span></a>数据降维（Dimensionality Reduction）</h3>
<p>数据降维，是指在某些限定条件下，降低随机变量个数，得到一组“不相关”主变量的过程。
数据降维技术中，PCA（principal components analysis）是应用最多的方法。</p>
<h4><a id="%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true" href="#%E4%BD%9C%E7%94%A8"><span class="octicon octicon-link"></span></a>作用</h4>
<ul>
<li>减少模型分析数据量，提升处理效率，降低计算难度；</li>
<li>实现数据可视化。</li>
</ul>
<h4><a id="pca" class="anchor" aria-hidden="true" href="#pca"><span class="octicon octicon-link"></span></a>PCA</h4>
<h5><a id="%E7%9B%AE%E6%A0%87" class="anchor" aria-hidden="true" href="#%E7%9B%AE%E6%A0%87"><span class="octicon octicon-link"></span></a>目标</h5>
<p>寻找k(k&lt;n)维新数据，使它们反映事物的主要特征。</p>
<h5><a id="%E6%A0%B8%E5%BF%83" class="anchor" aria-hidden="true" href="#%E6%A0%B8%E5%BF%83"><span class="octicon octicon-link"></span></a>核心</h5>
<p>在信息损失尽可能少的情况下，降低数据维度。</p>
<h4><a id="%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true" href="#%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="octicon octicon-link"></span></a>计算过程</h4>
<ol>
<li>原始数据预处理（标准化：\(\mu = 0, \delta=1\)）</li>
<li>计算协方差矩阵特征向量，以及数据在各特征向量投影后的方差</li>
<li>根据需求（任务指定或方差比例）确定降维维度k</li>
<li>选取k维特征向量，计算数据在其形成空间的投影</li>
</ol>
<h2><a id="iris%E6%95%B0%E6%8D%AE%E9%9B%86" class="anchor" aria-hidden="true" href="#iris%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="octicon octicon-link"></span></a>Iris数据集</h2>
<p>Iris鸢(yuan)尾花数据集是一个经典数据集，在统计学习和机器学习领域都经常被用作示例</p>
<h2><a id="%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83" class="anchor" aria-hidden="true" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="octicon octicon-link"></span></a>决策树模型训练</h2>
<pre><code class="language-python">from sklearn import tree
# 实例化一个决策树模型
dc_tree = tree.DecisionTreeClassifier(criterion='entropy', min_samples_leaf=5)
# 训练模型
dc_tree.fit(X, y)

# 可视化决策树
tree.plot_tree(dc_tree, filled='Tree',
feature_names=['SepalLength','SepalWidth','PetalLength','PetalWidth'], 
class_names=['setosa','versicolor','virginica']    
)
</code></pre>
<blockquote>
<p>criterion='entropy', 采用信息增益最大化（ID3算法），min_samples_leaf=5 表示样本数量多少就不去在分的数量</p>
</blockquote>
<h2><a id="%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83" class="anchor" aria-hidden="true" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="octicon octicon-link"></span></a>异常检测模型训练</h2>
<pre><code class="language-python">from sklearn.covariance import EllipticEnvelope
clf = EllipticEnvelope()
clf.fit(data)

# 可视化异常数据
anamoly_points = plt.scatter(
    data.loc[:, 'x1'][y_predict == -1],
    data.loc[:, 'x2'][y_predict == -1],
    marker = 'o',
    facecolor = &quot;none&quot;,
    edgecolor = &quot;red&quot;,
    s = 250
)
</code></pre>
<h2><a id="pca-iris%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%E5%90%8E%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true" href="#pca-iris%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%E5%90%8E%E5%88%86%E7%B1%BB"><span class="octicon octicon-link"></span></a>PCA(iris数据降维后分类)</h2>
<pre><code class="language-python"># 模型训练获得PCA降维后数据
from sklearn.decomposition import PCA
# n_components表示维度，等于4就是4维
pca = PCA(n_components=4)
X_reduced = pca.fit_transform(X_norm)
</code></pre>
<blockquote>
<p>X_norm是标准化处理之后的数据，标准化处理的方式：</p>
</blockquote>
<pre><code class="language-python">from sklearn.preprocessing import StandardScaler
X_norm = StandardScaler().fit_transform(X)
</code></pre>
<h2><a id="%E8%AE%A1%E7%AE%97%E5%90%84%E6%88%90%E5%88%86%E6%8A%95%E5%BD%B1%E6%95%B0%E6%8D%AE%E6%96%B9%E5%B7%AE%E6%AF%94%E4%BE%8B" class="anchor" aria-hidden="true" href="#%E8%AE%A1%E7%AE%97%E5%90%84%E6%88%90%E5%88%86%E6%8A%95%E5%BD%B1%E6%95%B0%E6%8D%AE%E6%96%B9%E5%B7%AE%E6%AF%94%E4%BE%8B"><span class="octicon octicon-link"></span></a>计算各成分投影数据方差比例</h2>
<pre><code class="language-python">var_ratio = pca.explained_variance_ratio_
</code></pre>
<h2><a id="%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E5%B7%AE%E6%AF%94%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E5%B7%AE%E6%AF%94%E4%BE%8B%EF%BC%9A"><span class="octicon octicon-link"></span></a>可视化方差比例：</h2>
<pre><code class="language-python">plt.bar([1,2,3,4], var_ratio)
plt.title('variance ratio of each component')
plt.xticks([1,2,3,4], ['PC1','PC2','PC3','PC4'])
plt.ylabel('var_ratio')
plt.show()
</code></pre>
<h2><a id="%E5%8F%AF%E8%A7%86%E5%8C%96pca%E5%90%8E%E6%95%B0%E6%8D%AE%EF%BC%9A" class="anchor" aria-hidden="true" href="#%E5%8F%AF%E8%A7%86%E5%8C%96pca%E5%90%8E%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="octicon octicon-link"></span></a>可视化PCA后数据：</h2>
<pre><code class="language-python">setosa = plt.scatter(X_reduced[:,0][y==0], X_reduced[:,1][y==0])
versicolor = plt.scatter(X_reduced[:,0][y==1], X_reduced[:,1][y==1])
virginica = plt.scatter(X_reduced[:,0][y==2], X_reduced[:,1][y==2])
</code></pre>
<p>获取均值和标准差方法：<br />
均值：</p>
<pre><code class="language-python">mean = data.mean()
</code></pre>
<p>标准差：</p>
<pre><code class="language-python">sigma = data.std()
</code></pre>

]]></content>
  </entry>
  
</feed>
