<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jythons小站]]></title>
  <link href="jythons.github.io/atom.xml" rel="self"/>
  <link href="jythons.github.io/"/>
  <updated>2020-12-28T23:32:21+08:00</updated>
  <id>jythons.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[ES数据类型]]></title>
    <link href="jythons.github.io/16093421785520.html"/>
    <updated>2020-12-30T23:29:38+08:00</updated>
    <id>jythons.github.io/16093421785520.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">核心数据类型</h2>

<h3 id="toc_1">字符串类型 - string（不在支持）</h3>

<h4 id="toc_2">使用示例</h4>

<pre><code class="language-text">PUT website
{
    &quot;mappings&quot;: {
        &quot;blog&quot;: {
            &quot;properties&quot;: {
                &quot;title&quot;: {&quot;type&quot;: &quot;string&quot;},    // 全文本
                &quot;tags&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot;} // 关键字, 不分词
            }
        }
    }
}
</code></pre>

<h4 id="toc_3">ES 5.6.10中的响应信息</h4>

<pre><code class="language-text">#! Deprecation: The [string] field is deprecated, please use [text] or [keyword] instead on [tags]
#! Deprecation: The [string] field is deprecated, please use [text] or [keyword] instead on [title]
{
  &quot;acknowledged&quot;: true,
  &quot;shards_acknowledged&quot;: true,
  &quot;index&quot;: &quot;website&quot;
}
</code></pre>

<h4 id="toc_4">ES 6.6.0中的响应信息</h4>

<pre><code class="language-text">{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;mapper_parsing_exception&quot;,
        &quot;reason&quot;: &quot;No handler for type [string] declared on field [title]&quot;
      }
    ],
    &quot;type&quot;: &quot;mapper_parsing_exception&quot;,
    &quot;reason&quot;: &quot;Failed to parse mapping [blog]: No handler for type [string] declared on field [title]&quot;,
    &quot;caused_by&quot;: {
      &quot;type&quot;: &quot;mapper_parsing_exception&quot;,
      &quot;reason&quot;: &quot;No handler for type [string] declared on field [title]&quot;
    }
  },
  &quot;status&quot;: 400
}
</code></pre>

<blockquote>
<p>string类型的field已经被移除了，我们需要使用text或keyword类型来代替string。</p>
</blockquote>

<h3 id="toc_5">文本类型 - text</h3>

<p>在ES5.4版本开始，text取代了需要分词的string。<br/>
当一个字段需要使用与全文搜索（会被分词），比如产品名称、产品描述信息，就应该使用text类型。</p>

<blockquote>
<p>text的内容会被分词，可以设置是否需要存储：<code>&quot;index&quot;: &quot;true|false&quot;</code>.<br/>
text类型的字段不能用于排序，也很少用于聚合。</p>
</blockquote>

<h4 id="toc_6">使用示例</h4>

<pre><code class="language-text">PUT website
{
    &quot;mappings&quot;: {
        &quot;blog&quot;: {
            &quot;properties&quot;: {
                &quot;summary&quot;: {&quot;type&quot;: &quot;text&quot;, &quot;index&quot;: &quot;true&quot;}
            }
        }
    }
}
</code></pre>

<h3 id="toc_7">关键字类型 - keyword</h3>

<p>在ES5.4版本开始，keyword取代了不需要分词的string。<br/>
当一个字段需要按照精确值进行过滤、排序、聚合等操作时，就应该使用keyword类型。</p>

<blockquote>
<p>keyword的内容不会被分词，可以设置是否需要存储：<code>&quot;index&quot;: &quot;true|false&quot;</code></p>
</blockquote>

<h4 id="toc_8">使用示例</h4>

<pre><code class="language-text">PUT website
{
    &quot;mappings&quot;: {
        &quot;blog&quot;: {
            &quot;properties&quot;: {
                &quot;tags&quot;: {&quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: &quot;true&quot;}
            }
        }
    }
}
</code></pre>

<h3 id="toc_9">数字类型 - 8种</h3>

<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>byte</td>
<td>有符号的8位整数，范围：[-128 ~ 127]</td>
</tr>
<tr>
<td>short</td>
<td>有符号的16位整数，范围：[-32768 ~ 32767]</td>
</tr>
<tr>
<td>integer</td>
<td>有符号的32位整数，范围：[-2<sup>31</sup> ~ 2<sup>31-1]</sup></td>
</tr>
<tr>
<td>long</td>
<td>有符号的64位整数，范围：[-2<sup>63</sup> ~ 2<sup>63-1]</sup></td>
</tr>
<tr>
<td>float</td>
<td>32位单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>64位双精度浮点数</td>
</tr>
<tr>
<td>half_float</td>
<td>16位半精度IEEE 754浮点类型</td>
</tr>
<tr>
<td>scaled_float</td>
<td>缩放类型的浮点数，比如price字段只需要精确到分，57.34缩放因子为100，存储结果为5734</td>
</tr>
</tbody>
</table>

<blockquote>
<p>使用注意事项：<br/>
尽可能选择范围小的数据类型，字段的长度越短，索引和搜索的效率越高；<br/>
优先考虑使用带缩放因子的浮点类型。</p>
</blockquote>

<h4 id="toc_10">使用示例</h4>

<pre><code class="language-text">PUT shop
{
    &quot;mappings&quot;: {
        &quot;book&quot;: {
            &quot;properties&quot;: {
                &quot;name&quot;: {&quot;type&quot;: &quot;text&quot;},
                &quot;quantity&quot;: {&quot;type&quot;: &quot;integer&quot;},  // integer类型
                &quot;price&quot;: {
                    &quot;type&quot;: &quot;scaled_float&quot;,       // scaled_float类型
                    &quot;scaling_factor&quot;: 100
                }
            }
        }
    }
}
</code></pre>

<h3 id="toc_11">日期类型 - date</h3>

<p>JSON没有日期数据类型，所以在ES中，日期可以是：</p>

<ul>
<li>包含格式化日期的字符串，&quot;2020-12-30&quot;，或&quot;2020-12-30 12:00:00&quot;</li>
<li>代表时间毫秒数的长整型数字</li>
<li>代表时间秒数的整数</li>
</ul>

<blockquote>
<p>如果时区未指定，日期将被转换为UTC格式，单存储的却是长整型的毫秒值<br/>
可以自定义日期格式，若未指定，则使用默认格式：<code>strict_date_optional_time|epoch_millis</code></p>
</blockquote>

<h4 id="toc_12">使用日期格式示例</h4>

<pre><code class="language-text">// 添加映射
PUT website
{
    &quot;mappings&quot;: {
        &quot;blog&quot;: {
            &quot;properties&quot;: {
                &quot;pub_date&quot;: {&quot;type&quot;: &quot;date&quot;}   // 日期类型
            }
        }
    }
}

// 添加数据
PUT website/blog/11
{ &quot;pub_date&quot;: &quot;2018-10-10&quot; }

PUT website/blog/12
{ &quot;pub_date&quot;: &quot;2018-10-10T12:00:00Z&quot; }  // Solr中默认使用的日期格式

PUT website/blog/13
{ &quot;pub_date&quot;: &quot;1589584930103&quot; }         // 时间的毫秒值
</code></pre>

<h4 id="toc_13">多种日期格式</h4>

<blockquote>
<p>多个格式使用双竖线<code>||</code>分隔，每个格式都会被依次尝试，直到找到匹配的<br/>
第一个格式用于将时间毫秒值转换为对应格式的字符串。</p>
</blockquote>

<h5 id="toc_14">使用示例</h5>

<pre><code class="language-text">// 添加映射
PUT website
{
    &quot;mappings&quot;: {
        &quot;blog&quot;: {
            &quot;properties&quot;: {
                &quot;date&quot;: {
                    &quot;type&quot;: &quot;date&quot;,  // 可以接受如下类型的格式
                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;
                }
            }
        }
    }
}
</code></pre>

<h3 id="toc_15">布尔类型 - boolean</h3>

<p>可以接受表示真、假的字符串或数字：</p>

<ul>
<li>真值：true, &quot;true&quot;, &quot;on&quot;, &quot;yes&quot;, &quot;1&quot; ...</li>
<li>假值: false, &quot;false&quot;, &quot;off&quot;, &quot;no&quot;, &quot;0&quot;, &quot;&quot;(空字符串), 0.0, 0</li>
</ul>

<h3 id="toc_16">二进制型 - binary</h3>

<p>二进制类型是Base64编码字符串的二进制值, 不以默认的方式存储, 且不能被搜索. 有2个设置项:</p>

<blockquote>
<p>doc_values: 该字段是否需要存储到磁盘上, 方便以后用来排序、聚合或脚本查询. 接受true和false(默认);<br/>
store: 该字段的值是否要和_source分开存储、检索, 意思是除了_source中, 是否要单独再存储一份. 接受true或false(默认).</p>
</blockquote>

<h4 id="toc_17">使用示例</h4>

<pre><code class="language-text">// 添加映射
PUT website
{
    &quot;mappings&quot;: {
        &quot;blog&quot;: {
            &quot;properties&quot;: {
                &quot;blob&quot;: {&quot;type&quot;: &quot;binary&quot;}   // 二进制
            }
        }
    }
}
// 添加数据
PUT website/blog/1
{
    &quot;title&quot;: &quot;Some binary blog&quot;,
    &quot;blob&quot;: &quot;hED903KSrA084fRiD5JLgY==&quot;
}
</code></pre>

<blockquote>
<p>注意: Base64编码的二进制值不能嵌入换行符\n, 逗号(0x2c)等符号.</p>
</blockquote>

<h3 id="toc_18">范围类型 - range</h3>

<p>range类型支持一下几种：</p>

<table>
<thead>
<tr>
<th style="text-align: left">类型</th>
<th style="text-align: left">范围</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">integer_range</td>
<td style="text-align: left">−2<sup>31</sup> ~ 2<sup>31−1</sup></td>
</tr>
<tr>
<td style="text-align: left">long_range</td>
<td style="text-align: left">−2<sup>63</sup> ~ 2<sup>63−1</sup></td>
</tr>
<tr>
<td style="text-align: left">float_range</td>
<td style="text-align: left">32位单精度浮点型</td>
</tr>
<tr>
<td style="text-align: left">double_range</td>
<td style="text-align: left">64位双精度浮点型</td>
</tr>
<tr>
<td style="text-align: left">date_range</td>
<td style="text-align: left">64位整数, 毫秒计时</td>
</tr>
<tr>
<td style="text-align: left">ip_range</td>
<td style="text-align: left">IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在</td>
</tr>
</tbody>
</table>

<h4 id="toc_19">添加映射</h4>

<pre><code class="language-text">PUT company
{
    &quot;mappings&quot;: {
        &quot;department&quot;: {
            &quot;properties&quot;: {
                &quot;expected_number&quot;: {  // 预期员工数
                    &quot;type&quot;: &quot;integer_range&quot;
                },
                &quot;time_frame&quot;: {       // 发展时间线
                    &quot;type&quot;: &quot;date_range&quot;, 
                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;
                },
                &quot;ip_whitelist&quot;: {     // ip白名单
                    &quot;type&quot;: &quot;ip_range&quot;
                }
            }
        }
    }
}
</code></pre>

<h4 id="toc_20">添加数据</h4>

<pre><code class="language-text">PUT company/department/1
{
    &quot;expected_number&quot; : {
        &quot;gte&quot; : 10,
        &quot;lte&quot; : 20
    },
    &quot;time_frame&quot; : { 
        &quot;gte&quot; : &quot;2018-10-01 12:00:00&quot;, 
        &quot;lte&quot; : &quot;2018-11-01&quot;
    }, 
    &quot;ip_whitelist&quot;: &quot;192.168.0.0/16&quot;
}
</code></pre>

<p>查询数据</p>

<pre><code class="language-text">GET company/department/_search
{
    &quot;query&quot;: {
        &quot;term&quot;: {
            &quot;expected_number&quot;: {
                &quot;value&quot;: 12
            }
        }
    }
}
GET company/department/_search
{
    &quot;query&quot;: {
        &quot;range&quot;: {
            &quot;time_frame&quot;: {
                &quot;gte&quot;: &quot;208-08-01&quot;,
                &quot;lte&quot;: &quot;2018-12-01&quot;,
                &quot;relation&quot;: &quot;within&quot; 
            }
        }
    }
}
</code></pre>

<h4 id="toc_21">查询结果</h4>

<pre><code class="language-text">{
  &quot;took&quot;: 26,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 1,
    &quot;max_score&quot;: 1.0,
    &quot;hits&quot;: [
      {
        &quot;_index&quot;: &quot;company&quot;,
        &quot;_type&quot;: &quot;department&quot;,
        &quot;_id&quot;: &quot;1&quot;,
        &quot;_score&quot;: 1.0,
        &quot;_source&quot;: {
          &quot;expected_number&quot;: {
            &quot;gte&quot;: 10,
            &quot;lte&quot;: 20
          },
          &quot;time_frame&quot;: {
            &quot;gte&quot;: &quot;2018-10-01 12:00:00&quot;,
            &quot;lte&quot;: &quot;2018-11-01&quot;
          },
          &quot;ip_whitelist&quot; : &quot;192.168.0.0/16&quot;
        }
      }
    ]
  }
}
</code></pre>

<h2 id="toc_22">复杂数据类型</h2>

<h3 id="toc_23">数组类型 - array</h3>

<p>ES中没有专门的数组类型，直接使用[]定义即可；<br/>
数组中所有的值必须是同一种数据类型, 不支持混合数据类型的数组</p>

<blockquote>
<p>字符串数组: [&quot;one&quot;, &quot;two&quot;];<br/>
整数数组: [1, 2];<br/>
由数组组成的数组: [1, [2, 3]], 等价于[1, 2, 3];<br/>
对象数组: [{&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20}, {&quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 18}].</p>
</blockquote>

<p>注意</p>

<blockquote>
<p>动态添加数据时, 数组中第一个值的类型决定整个数组的类型;<br/>
不支持混合数组类型, 比如[1, &quot;abc&quot;];<br/>
数组可以包含null值, 空数组[]会被当做missing field —— 没有值的字段.</p>
</blockquote>

<h3 id="toc_24">对象类型 - object</h3>

<p>JSON文档是分层的: 文档可以包含内部对象, 内部对象也可以包含内部对象。</p>

<h4 id="toc_25">使用示例</h4>

<pre><code class="language-text">PUT employee/developer/1
{
    &quot;name&quot;: &quot;ma_shoufeng&quot;,
    &quot;address&quot;: {
        &quot;region&quot;: &quot;China&quot;,
        &quot;location&quot;: {&quot;province&quot;: &quot;GuangDong&quot;, &quot;city&quot;: &quot;GuangZhou&quot;}
    }
}
</code></pre>

<h4 id="toc_26">存储方式</h4>

<pre><code class="language-text">{
    &quot;name&quot;:                       &quot;ma_shoufeng&quot;,
    &quot;address.region&quot;:             &quot;China&quot;,
    &quot;address.location.province&quot;:  &quot;GuangDong&quot;, 
    &quot;address.location.city&quot;:      &quot;GuangZhou&quot;
}
</code></pre>

<h4 id="toc_27">文档的映射结构类似为</h4>

<pre><code class="language-text">PUT employee
{
    &quot;mappings&quot;: {
        &quot;developer&quot;: {
            &quot;properties&quot;: {
                &quot;name&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;index&quot;: &quot;true&quot; }, 
                &quot;address&quot;: {
                    &quot;properties&quot;: {
                        &quot;region&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: &quot;true&quot; },
                        &quot;location&quot;: {
                            &quot;properties&quot;: {
                                &quot;province&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: &quot;true&quot; },
                                &quot;city&quot;: { &quot;type&quot;: &quot;keyword&quot;, &quot;index&quot;: &quot;true&quot; }
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<h3 id="toc_28">嵌套类型 - nested</h3>

<p>嵌套类型是对象数据类型的一个特例, 可以让array类型的对象被独立索引和搜索.</p>

<h4 id="toc_29">对象数组是如何存储的</h4>

<h5 id="toc_30">添加数据</h5>

<pre><code class="language-text">PUT game_of_thrones/role/1
{
    &quot;group&quot;: &quot;stark&quot;,
    &quot;performer&quot;: [
        {&quot;first&quot;: &quot;John&quot;, &quot;last&quot;: &quot;Snow&quot;},
        {&quot;first&quot;: &quot;Sansa&quot;, &quot;last&quot;: &quot;Stark&quot;}
    ]
}
</code></pre>

<h5 id="toc_31">内部存储结构</h5>

<pre><code class="language-text">{
    &quot;group&quot;:             &quot;stark&quot;,
    &quot;performer.first&quot;: [ &quot;john&quot;, &quot;sansa&quot; ],
    &quot;performer.last&quot;:  [ &quot;snow&quot;, &quot;stark&quot; ]
}
</code></pre>

<h5 id="toc_32">存储分析</h5>

<p>可以看出, user.first和user.last会被平铺为多值字段, 这样一来, John和Snow之间的关联性就丢失了.<br/>
在查询时, 可能出现John Stark的结果.</p>

<h4 id="toc_33">用nested类型解决object类型的不足</h4>

<p>如果需要对以最对象进行索引, 且保留数组中每个对象的独立性, 就应该使用嵌套数据类型.<br/>
嵌套对象实质是将每个对象分离出来, 作为隐藏文档进行索引.</p>

<h5 id="toc_34">创建映射</h5>

<pre><code class="language-text">PUT game_of_thrones
{
    &quot;mappings&quot;: {
        &quot;role&quot;: {
            &quot;properties&quot;: {
                &quot;performer&quot;: {&quot;type&quot;: &quot;nested&quot; }
            }
        }
    }
}
</code></pre>

<h5 id="toc_35">添加映射</h5>

<pre><code class="language-text">PUT game_of_thrones/role/1
{
    &quot;group&quot; : &quot;stark&quot;,
    &quot;performer&quot; : [
        {&quot;first&quot;: &quot;John&quot;, &quot;last&quot;: &quot;Snow&quot;},
        {&quot;first&quot;: &quot;Sansa&quot;, &quot;last&quot;: &quot;Stark&quot;}
    ]
}
</code></pre>

<h5 id="toc_36">检索数据</h5>

<pre><code class="language-text">GET game_of_thrones/_search
{
    &quot;query&quot;: {
        &quot;nested&quot;: {
            &quot;path&quot;: &quot;performer&quot;,
            &quot;query&quot;: {
                &quot;bool&quot;: {
                    &quot;must&quot;: [
                        { &quot;match&quot;: { &quot;performer.first&quot;: &quot;John&quot; }},
                        { &quot;match&quot;: { &quot;performer.last&quot;:  &quot;Snow&quot; }} 
                    ]
                }
            }, 
            &quot;inner_hits&quot;: {
                &quot;highlight&quot;: {
                    &quot;fields&quot;: {&quot;performer.first&quot;: {}}
                }
            }
        }
    }
}
</code></pre>

<h2 id="toc_37">地理数据类型</h2>

<h3 id="toc_38">地理点类型 - geo point</h3>

<p>地理点类型用于存储地理位置的经纬度对, 可用于:</p>

<ul>
<li>查找一定范围内的地理点;</li>
<li>通过地理位置或相对某个中心点的距离聚合文档;</li>
<li>将距离整合到文档的相关性评分中;</li>
<li>通过距离对文档进行排序.</li>
</ul>

<h4 id="toc_39">添加映射</h4>

<pre><code class="language-text">PUT employee
{
    &quot;mappings&quot;: {
        &quot;developer&quot;: {
            &quot;properties&quot;: {
                &quot;location&quot;: {&quot;type&quot;: &quot;geo_point&quot;}
            }
        }
    }
}
</code></pre>

<h4 id="toc_40">存储地理位置</h4>

<pre><code class="language-text">// 方式一: 纬度 + 经度键值对
PUT employee/developer/1
{
    &quot;text&quot;: &quot;小蛮腰-键值对地理点参数&quot;, 
    &quot;location&quot;: {
        &quot;lat&quot;: 23.11, &quot;lon&quot;: 113.33     // 纬度: latitude, 经度: longitude
    }
}

// 方式二: &quot;纬度, 经度&quot;的字符串参数
PUT employee/developer/2
{
  &quot;text&quot;: &quot;小蛮腰-字符串地理点参数&quot;,
  &quot;location&quot;: &quot;23.11, 113.33&quot;           // 纬度, 经度
}

// 方式三: [&quot;经度, 纬度&quot;] 数组地理点参数
PUT employee/developer/3
{
  &quot;text&quot;: &quot;小蛮腰-数组参数&quot;,
  &quot;location&quot;: [ 113.33, 23.11 ]         // 经度, 纬度
}
</code></pre>

<h4 id="toc_41">查询示例</h4>

<pre><code class="language-text">GET employee/_search
{
    &quot;query&quot;: { 
        &quot;geo_bounding_box&quot;: { 
            &quot;location&quot;: {
                &quot;top_left&quot;: { &quot;lat&quot;: 24, &quot;lon&quot;: 113 },      // 地理盒子模型的上-左边
                &quot;bottom_right&quot;: { &quot;lat&quot;: 22, &quot;lon&quot;: 114 }   // 地理盒子模型的下-右边
            }
        }
    }
}
</code></pre>

<h3 id="toc_42">地理形状类型 - geo_shape</h3>

<p>是多边形的复杂形状. 使用较少, 这里省略.<br/>
可以参考这篇文章: <a href="https://blog.csdn.net/u012332735/article/details/54971638">Elasticsearch地理位置总结</a></p>

<h2 id="toc_43">专门数据类型</h2>

<h3 id="toc_44">IP类型</h3>

<p>IP类型的字段用于存储IPv4或IPv6的地址, 本质上是一个长整型字段.</p>

<h4 id="toc_45">添加映射</h4>

<pre><code class="language-text">PUT employee
{
    &quot;mappings&quot;: {
        &quot;customer&quot;: {
            &quot;properties&quot;: {
                &quot;ip_addr&quot;: { &quot;type&quot;: &quot;ip&quot; }
            }
        }
    }
}
</code></pre>

<h4 id="toc_46">添加数据</h4>

<pre><code class="language-text">PUT employee/customer/1
{ &quot;ip_addr&quot;: &quot;192.168.1.1&quot; }
</code></pre>

<h4 id="toc_47">查询数据</h4>

<pre><code class="language-text">GET employee/customer/_search
{
    &quot;query&quot;: {
        &quot;term&quot;: { &quot;ip_addr&quot;: &quot;192.168.0.0/16&quot; }
    }
}
</code></pre>

<h3 id="toc_48">计数数据类型 - token_count</h3>

<p>token_count类型用于统计字符串中的单词数量.<br/>
本质上是一个整数型字段, 接受并分析字符串值, 然后索引字符串中单词的个数.</p>

<h4 id="toc_49">添加映射</h4>

<pre><code class="language-text">PUT employee
{
    &quot;mappings&quot;: {
        &quot;customer&quot;: {
            &quot;properties&quot;: {
                &quot;name&quot;: { 
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;fields&quot;: {
                        &quot;length&quot;: {
                            &quot;type&quot;: &quot;token_count&quot;, 
                            &quot;analyzer&quot;: &quot;standard&quot;
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<h4 id="toc_50">添加数据</h4>

<pre><code class="language-text">PUT employee/customer/1
{ &quot;name&quot;: &quot;John Snow&quot; }
PUT employee/customer/2
{ &quot;name&quot;: &quot;Tyrion Lannister&quot; }
</code></pre>

<h4 id="toc_51">查询数据</h4>

<pre><code class="language-text">GET employee/customer/_search
{
    &quot;query&quot;: {
        &quot;term&quot;: { &quot;name.length&quot;: 2 }
    }
}
</code></pre>

<h2 id="toc_52">参考</h2>

<p><a href="https://www.cnblogs.com/shoufeng/p/10692113.html">ES 15 - Elasticsearch的数据类型 (text、keyword、date、object、geo等)</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES基本操作]]></title>
    <link href="jythons.github.io/16093414600296.html"/>
    <updated>2020-12-30T23:17:40+08:00</updated>
    <id>jythons.github.io/16093414600296.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">Mappings自定义创建映射</h2>

<h3 id="toc_1">创建mapping</h3>

<pre><code class="language-text">接口地址：http://es_service_addr/索引名称
请求方式：put
body: 
    {
        &quot;mappings&quot;: {
           # 属性
            &quot;properties&quot;: {
               # 字段
                &quot;realname&quot;: {
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;index&quot;: true  # index表示是否需要索引，true表示需要（默认），false表示不需要索引
                }
            }
        }
    }
</code></pre>

<h3 id="toc_2">响应</h3>

<pre><code class="language-text">{
    &quot;acknowledged&quot;: true,
    &quot;shards_acknowledged&quot;: true,
    &quot;index&quot;: &quot;index_mapping&quot;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch安装]]></title>
    <link href="jythons.github.io/16090525942611.html"/>
    <updated>2020-12-27T15:03:14+08:00</updated>
    <id>jythons.github.io/16090525942611.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">下载地址</h2>

<p><a href="https://www.elastic.co/cn/elasticsearch/">官方下载</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装方法</h2>

<p>1.下载安装包解压</p>

<pre><code class="language-text">tar -zxvf elasticsearch.tar.gz
</code></pre>

<p>2.将解压出来的文件夹转移到/user/lcoal文件夹下</p>

<pre><code class="language-text">mv elasticsearch /usr/local/
</code></pre>

<p>3.创建一个用于存放数据的目录</p>

<pre><code class="language-text">cd /usr/lcoal/elasticsearch/
mkdir data
</code></pre>

<p>4.修改核心配置文件</p>

<pre><code class="language-text">vim ./config/elasticsearch.yml

# 配置文件解析
cluster.name: my-application                # 集群名称
node.name: node-name                        # 节点名称
# paths相关配置
path.data: /usr/lcoal/elasticsearch/data    # 存放数据的目录
path.logs: /usr/lcoal/elasticsearch/logs    # 存放日志的目录
# 网络相关的配置
network.host: 0.0.0.0
http.port: 9200 
# 配置跨域访问
http.cors.enabled: true
http.core.allow-origin: &quot;*&quot;
# 节点相关的配置
# 这里的节点名称要与上面配置的node.name的名称相同
cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]
</code></pre>

<pre><code class="language-text">vim ./config/jvm.options

修改内存大小
-Xms1g # 初始化内存空间，默认1G，虚拟机建议修改为128m
-Xmx1g # 最大使用内存空间，默认1G，虚拟机建议修改为128m
</code></pre>

<blockquote>
<p>ES是不允许使用root用户启动的，启动ES需要使用非root用户启动。<br/>
创建一个新用户：useradd esuser<br/>
为esuser用户授权：chown -R esuser:esuser /usr/lcoal/elasticsearch</p>
</blockquote>

<p>5.启动ES<br/>
进入到/usr/lcoal/elasticsearch/bin目录下</p>

<pre><code class="language-text">切换为esuser用户
su esuser
启动ES
./elasticsearch
</code></pre>

<blockquote>
<p>启动时可能会遇到的错误<br/>
1.max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]<br/>
2.max number of threads [3756] for user [esuser] is too low, increase to at least [4096]<br/>
3.max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]<br/>
问题1：能够打开的文件数过少<br/>
问题2：支持的最大线程数过少<br/>
问题3：支持最大虚拟内存vm.max_map_count数太低<br/>
解决以上问题，需要修改配置文件: /etc/security/limits.conf<br/>
添加如下配置：</p>

<pre><code class="language-text">* soft nofile 65536
* hard nofile 131072
* soft nproc 4096
* hard nproc 4096
</code></pre>

<p>然后在/etc/sysctl.d文件内添加如下配置：</p>

<pre><code class="language-text">vm.max_map_count=262145
</code></pre>

<p>修改/etc/sysctl.d文件需要刷新：<code>sysctl -p</code><br/>
如果还是不能启动，重启服务器即可</p>
</blockquote>

<p>6.后台启动ES</p>

<pre><code class="language-text">./elasticsearch -d
</code></pre>

<h2 id="toc_2">文件解析</h2>

<table>
<thead>
<tr>
<th>文件夹</th>
<th>子文件</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>bin</td>
<td></td>
<td>可执行文件等</td>
<td></td>
</tr>
<tr>
<td>config</td>
<td></td>
<td>配置</td>
<td></td>
</tr>
<tr>
<td></td>
<td>elasticsearch.yml</td>
<td>核心配置文件</td>
<td></td>
</tr>
<tr>
<td>jdk</td>
<td></td>
<td>java依赖</td>
<td></td>
</tr>
<tr>
<td>lib</td>
<td></td>
<td>工具类</td>
<td></td>
</tr>
<tr>
<td>logs</td>
<td></td>
<td>日志</td>
<td></td>
</tr>
<tr>
<td>modules</td>
<td></td>
<td>ES模块</td>
<td></td>
</tr>
<tr>
<td>plugins</td>
<td></td>
<td>ES拓展</td>
<td></td>
</tr>
<tr>
<td>data</td>
<td></td>
<td>用于存放数据</td>
<td>自己创建</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">安装ES可视化插件（elasticsearch-head）</h2>

<p><a href="https://github.com/mobz/elasticsearch-head">elasticsearch-head</a>插件可以去上去下载，具体安装方法可以参考GitHub的README.md说明。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch原理]]></title>
    <link href="jythons.github.io/16076110407363.html"/>
    <updated>2020-12-10T22:37:20+08:00</updated>
    <id>jythons.github.io/16076110407363.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">Lucene</h2>

<p>Lucene是一个代码库，使用Java开发的搜索引擎，不利于分布式拓展。</p>

<h2 id="toc_1">Solr</h2>

<p>Slor是基于Lucene开发的搜索引擎，是apache开源的搜索引擎，只支持Java。</p>

<h2 id="toc_2">Elasticsearch</h2>

<p>ES也是基于Lucene开发，支持分布式，以及多种语言，拓展性比较好。支持TB级别的搜索（TB级别是1024T容量查询）。<br/>
ES是基于文档去检索的。</p>

<h3 id="toc_3">ES核心术语</h3>

<ul>
<li>索引 Index
<ul>
<li>相当于数据库的表</li>
</ul></li>
<li>类型 type
<ul>
<li>相当于表的逻辑类型，用于区分索引，ES 7.x已经不在使用了，老得版本还在使用</li>
</ul></li>
<li>文档 document
<ul>
<li>相当于行，是json的形式去存在的</li>
</ul></li>
<li>字段 fields
<ul>
<li>列 </li>
</ul></li>
<li>映射 mapping
<ul>
<li>相当于表结构定义</li>
</ul></li>
<li>近实时 NRT
<ul>
<li>Near real time 接近真实的时间，当新建一个文档之后，一般会有1秒左右的时间的延时</li>
</ul></li>
<li>节点 node
<ul>
<li>每一个服务器，就是一个节点</li>
</ul></li>
<li>shard replica
<ul>
<li>数据分片与备份</li>
</ul></li>
</ul>

<h4 id="toc_4">集群相关</h4>

<p><img src="media/16076110407363/ES%E6%9E%B6%E6%9E%84%E7%89%B9%E7%82%B9.png" alt="ES架构特点"/></p>

<p>分片（shard）：把索引库拆分为多份，分别放在不同的节点上，比如有3个节点，3个节点的所有数据内容加在一起是一个完整的索引库，分别保存到三个节点上，目的为了水平拓展，提高吞吐量。<br/>
备份（replica）：每个shard的备份。</p>

<h4 id="toc_5">简称</h4>

<p>shard = primary shard（主分片）<br/>
replica = replica shard（备份节点）</p>

<h4 id="toc_6">倒排索引</h4>

<p>倒排索引就是将正排索引的文档内容进行分词，然后记录这个词在每个文档出现的文档ID。<br/>
<img src="media/16076110407363/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" alt="倒排索引"/><br/>
词频TF：位置POS<br/>
词频是记录这个词在那个文档下出现的次数和位置，记录方法：1:1:<1>，表示文档ID1下，出现过1次，在下标为1的位置。<br/>
<img src="media/16076110407363/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E8%AF%8D%E9%A2%91.png" alt="倒排索引词频"/></p>

<blockquote>
<p>倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括u一个属性值和包含该属性的各个记录地址。由于不是根据记录来确定属性，而是根据属性来确定记录的位置，所以称之为倒排索引。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot使用模版]]></title>
    <link href="jythons.github.io/16073547198404.html"/>
    <updated>2020-12-07T23:25:19+08:00</updated>
    <id>jythons.github.io/16073547198404.html</id>
    <content type="html"><![CDATA[
<p>SpringBoot使用html模版，Controller需要使用注解：@Controller</p>

<h2 id="toc_0">pom配置</h2>

<pre><code class="language-text">&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<h2 id="toc_1">yml配置</h2>

<pre><code class="language-text">spring:
    thymeleaf:
    mode: HTML
    encoding: UTF-8
    prefix: classpath:/templates/
    suffix: .html
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot会话拦截器]]></title>
    <link href="jythons.github.io/16073519255991.html"/>
    <updated>2020-12-07T22:38:45+08:00</updated>
    <id>jythons.github.io/16073519255991.html</id>
    <content type="html"><![CDATA[
<p>会话拦截器，用于在请求一些接口之前，统一去拦截请求，进行验证等操作。</p>

<span id="more"></span><!-- more -->

<pre><code class="language-text">package com.sample.controller.interceptor;
import org.springframework.web.servlet.HandlerInterceptor;

public class UserTokenInterceptor implements HandlerInterceptor {
    
    /**
     * 拦截请求，在访问controller调用之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response,
                             Object handler){
         
    }
    
    /**
     * 请求访问controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    /**
     * 请求访问controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre>

<blockquote>
<p>以上配置好之后，还需要将拦截器注册一下才可使用。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringSession yml配置]]></title>
    <link href="jythons.github.io/16073500415348.html"/>
    <updated>2020-12-07T22:07:21+08:00</updated>
    <id>jythons.github.io/16073500415348.html</id>
    <content type="html"><![CDATA[
<p>使用SpringSession，需要先引入依赖，查看Maven Dependency Spring Session, 目前都是使用分布式的方式部署，因此使用redis会好一点。</p>

<h2 id="toc_0">Application配置</h2>

<pre><code class="language-text">spring:
    session:
        store-type: redis
</code></pre>

<h2 id="toc_1">配置启动</h2>

<p>在启动类里面配置启动</p>

<pre><code class="language-text">// 开启使用redis作为Spring Session
@EnableRedisHttpSession
</code></pre>

<h2 id="toc_2">使用方法</h2>

<pre><code class="language-text">public Object setSession(HttpServletRequest request) {
    HttpSession session = request.getSession();
    session.setAttribute(&quot;userInfo&quot;, &quot;XXX&quot;);
    session.setMaxInactiveInterval(3600);
    session.getAttribute(&quot;userInfo);
    session.removeAttribute(&quot;userInfo&quot;);
}
</code></pre>

<blockquote>
<p>因为使用Spring Session，需要安装Spring安全框架依赖，因为安装了这个依赖后，程序每次访问都需要登录，很麻烦，因此在启动类将它排除即可。排除方法见下方：</p>
</blockquote>

<pre><code class="language-text">@SpringBootApplication(exclude = {SecurityAutoConfiguration.class})
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven Dependency]]></title>
    <link href="jythons.github.io/16073491976884.html"/>
    <updated>2020-12-07T21:53:17+08:00</updated>
    <id>jythons.github.io/16073491976884.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<pre><code class="language-text">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;!-- 打包war [2] 移除自带内置tomcat --&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
        
&lt;!-- redis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- SpringSession --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- Spring 安全框架 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- apache 工具类 --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;commons-codec&lt;/groupId&gt;
      &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
      &lt;version&gt;1.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
      &lt;version&gt;3.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mysql驱动 --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.41&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mybatis --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 通用mapper逆向工具 --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.5&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--pagehelper --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
      &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;1.2.12&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--引入日志依赖 抽象层 与 实现层--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
    &lt;version&gt;1.7.21&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;version&gt;1.7.21&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 打包war [3] 添加依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- html模版 --&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存雪崩预防]]></title>
    <link href="jythons.github.io/16068348833531.html"/>
    <updated>2020-12-01T23:01:23+08:00</updated>
    <id>jythons.github.io/16068348833531.html</id>
    <content type="html"><![CDATA[
<p>当缓存大面积失效，请求会全部打到数据库上，这种情况就是雪崩。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">预防方法</h2>

<ul>
<li>设置缓存用不过期</li>
<li>过期时间错开</li>
<li>多级缓存</li>
<li>采购第三方Redis</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot集成Redis集群]]></title>
    <link href="jythons.github.io/16067500364861.html"/>
    <updated>2020-11-30T23:27:16+08:00</updated>
    <id>jythons.github.io/16067500364861.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">使用集群的配置</h2>

<pre><code class="language-text">spring:
    redis:
        password: mima
        cluster:
            nodes: 192.168.1.201:6379,192.168.1.202:6379,192.168.1.203:6379,192.168.1.204:6379,192.168.1.205:6379,192.168.1.206:6379,
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis-Cluster集群]]></title>
    <link href="jythons.github.io/16067481675978.html"/>
    <updated>2020-11-30T22:56:07+08:00</updated>
    <id>jythons.github.io/16067481675978.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">集群配置</h2>

<p>打开redis配置文件，找到 REDIS CLUSTER 配置块。修改以下配置：</p>

<pre><code class="language-text"># 开启redis-cluster集群配置
cluster-enabled yes
# 每一个节点在集群中的配置文件, 该文件有redis自己去维护 
cluster-config-file nodes-6379.conf
# 超时时间，超时自动切换
cluster-node-timeout 5000
# aof模式
appendonly yes
# aof日志文件名
appendfilename &quot;appendonly.aof&quot;
</code></pre>

<blockquote>
<p>构建集群时，需要将.rdb文件和.aof文件删除或者清空，否则会报错。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_1">构建集群</h2>

<blockquote>
<p>早期，构建redis集群使用的是ruby去构建的，在redis源码目录下，进入到src目录，下面有一个.rb的ruby脚本，通过这个脚本来构建集群，新版本不在使用这个方式。</p>
</blockquote>

<p>新版本构建方法</p>

<pre><code class="language-text">redis-cli --cluster help 回车，可以查看命令使用方法

# create 后面的地址是集群所有节点的地址，--cluster-replicas表示slave节点和master节点的比值，1就是1个master对应1个slave
redis-cli --cluster create 192.168.1.201:6379 192.168.1.202:6379 192.168.1.203:6379 192.168.1.204:6379 192.168.1.205:6379 192.168.1.206:6379 --cluster-replicas 1
</code></pre>

<blockquote>
<p>创建集群时，如果报错没有权限，在命令开头加上：-a 密码，即可</p>
</blockquote>

<p>检查集群是否创建成功</p>

<pre><code class="language-text">redis-cli --cluster 192.168.1.201:6379 
# 会输出集群各个节点信息
</code></pre>

<h2 id="toc_2">slot槽节点</h2>

<p>槽节点是在master节点上平均分配的，slave节点是没有槽节点的，数据就是保存在这个槽位里面的。<br/>
<img src="media/16067481675978/slot%E8%8A%82%E7%82%B9.png" alt="slot节点"/></p>

<h3 id="toc_3">槽slot怎么存储</h3>

<p>当我们存储一个key的时候，redis会根据这个key去hash一个值，然后取余槽节点总数，计算出来的值就是这个槽位的位置。<br/>
<img src="media/16067481675978/slot%E5%AD%98%E5%82%A8.png" alt="slot存储"/></p>

<blockquote>
<p>查看集群信息，cluster info<br/>
查看节点信息，cluster nodes</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot集成Redis哨兵]]></title>
    <link href="jythons.github.io/16067477234035.html"/>
    <updated>2020-11-30T22:48:43+08:00</updated>
    <id>jythons.github.io/16067477234035.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">哨兵模式配置</h2>

<pre><code class="language-text">spring:
    redis:
        database: 1
        password: imooc
        sentinel:
            master: master-redis # master节点名称
            nodes： 192.168.1.191:26379,192.168.1.191:26379,192.168.1.191:26379 # 哨兵节点地址
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis哨兵机制与实现]]></title>
    <link href="jythons.github.io/16062286652893.html"/>
    <updated>2020-11-24T22:37:45+08:00</updated>
    <id>jythons.github.io/16062286652893.html</id>
    <content type="html"><![CDATA[
<p>Redis使用源码安装的，在源码包内有一个 sentinel.conf 文件，这个文件就是哨兵机制的配置文件，将该配置文件拷贝到 /usr/local/redis 目录下。然后编辑配置即可。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">sentinel.conf配置</h2>

<pre><code class="language-text"># 绑定一个IP，如果redis需要暴漏在公网下，就需要绑定一个IP地址，
bind 127.0.0.1 192.168.1.1

# 是否开启保护模式, 默认：no 不开启，保证所有节点都可以访问
protected-mode no

# 端口号
port 26379

# 是否在后台启用
daemonize yes

# 哨兵的进程
pidfile /var/run/redis-sentinel.pid

# 日志文件
logfile /usr/local/redis/sentinel/redis-sentinel.log

# 工作目录
dir /usr/local/redis/sentinel

# 哨兵机制的核心配置：mymaster 相当于redis master节点的名称
# 后面的IP 端口是master节点的地址和端口，
# 最后面的2，表示多少个哨兵ping不通master，就可以决定这个节点挂掉了，
# 然后就可以故障转移了
sentinel monitor mymaster 127.0.0.1 6379 2

# 配置密码
sentinel auth-pass mymaster password

# 配置多少毫秒内断定节点属于宕机
sentinel down-after-milliseconds mymaster 30000

# 如果master挂掉之后，需要选举出一个slave节点作为master，这时其他的只节点需要和这个新的master节点同步数据，这个配置表示同步时的并行个数
sentinel parallel-syncs mymaster 1

# 发生故障时，需要做故障转移，如果某个哨兵在3分钟内（180000ms）没有操作，则由其他哨兵来完成转移
sentinel failover-timeout mymaster 180000
</code></pre>

<h2 id="toc_1">哨兵模式启动</h2>

<pre><code class="language-text">redis-sentinel /usr/local/redis/sentinel.conf
</code></pre>

<blockquote>
<p>当原来挂掉的主节点恢复了以后，他会自动变为slave节点，不在是master节点。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 缓存过期机制]]></title>
    <link href="jythons.github.io/16061468058717.html"/>
    <updated>2020-11-23T23:53:25+08:00</updated>
    <id>jythons.github.io/16061468058717.html</id>
    <content type="html"><![CDATA[
<ul>
<li>（主动）定期删除</li>
<li>（被动）惰性删除</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_0">定期删除</h2>

<p>定期删除就是redis会定期去抽查缓存是否过期，默认1秒钟10次（可自己配置），如果过期就会自动删除，删除后就不可访问。</p>

<pre><code class="language-text"># redis.conf
# 设置自动检查数量
hz 10
</code></pre>

<h2 id="toc_1">惰性删除</h2>

<p>惰性删除是指客户端请求的时候，可能会请求到一个过期的key，这时redis会去检查这个key是否过期，如果过期就会删除，这种策略对CPU比较友好，不会占用过多的CPU，缺点就是内存会被一直占用。</p>

<blockquote>
<p>以上两种策略只针对设置了过期时间的key生效。</p>
</blockquote>

<h2 id="toc_2">内存淘汰管理机制</h2>

<p>计算机的内存是有限的，redis自身带有内存管理机制（memory management）。<br/>
可以在配置文件内设置一个阀值（maxmemory），如果超过了这个阀值，redis会自动去清理，会清理那些没有设置过期时间的数据。</p>

<ul>
<li>noeviction (默认)
<ul>
<li>内存满了之后不允许继续写入</li>
</ul></li>
<li>volatile-lru
<ul>
<li>针对时间，选择时间最少的去清理</li>
</ul></li>
<li>allkeys-lru
<ul>
<li>针对时间选择key去清理，任何key都有可能被清理掉</li>
</ul></li>
<li>volatile-lfu
<ul>
<li>针对设置过缓存时间的，在这些缓存里面清理较少使用的数据</li>
</ul></li>
<li>allkeys-lfu （推荐）
<ul>
<li>当内存满了之后，有新的key需要写入时，他会清理那些不经常使用的缓存清理掉</li>
</ul></li>
<li>volatile-random
<ul>
<li>针对设置了过期时间的缓存，随机清理掉，任何key 都可能删除</li>
</ul></li>
<li>allkeys-random
<ul>
<li>随机删除，任何的key都有可能删除掉</li>
</ul></li>
<li>volatile-ttl
<ul>
<li>设置了过期时间的，即将要过期的优先淘汰</li>
</ul></li>
</ul>

<blockquote>
<p>LRU 针对时间的，使用最少<br/>
LFU 针对动作的，使用最少</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 主从复制原理]]></title>
    <link href="jythons.github.io/16057135385527.html"/>
    <updated>2020-11-18T23:32:18+08:00</updated>
    <id>jythons.github.io/16057135385527.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">主从架构</h2>

<p>单机单个节点，redis并发支持上万，但是随着业务的复杂度，redis的并发度还是会有上限的。因此还是需要在架构上进行优化。 <br/>
主从架构是一种水平横向拓展的架构，读写分离。 主节点负责数据的写入，从节点负责读操作。<br/>
<img src="media/16057135385527/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.png" alt="redis主从架构"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">主从原理</h2>

<p>当主节点和从节点启动后，在从节点会有一些相关的配置，启动后，从节点会对主节点发出ping请求，这时主节点会将全量数据复制给从节点，也就是复制RDB。<br/>
主节点会将内存里面的数据备份一个RDB文件，然后将RDB文件复制给从节点，从节点拿到主节点传过来的RDB文件后，将RDB文件的内容加载到从节点的内存当中。这是一个初始化的过程，当以后主节点有数据写入时，主节点会把命令发送给从节点，从节点将数据写入到内存。<br/>
<img src="media/16057135385527/redis%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png" alt="redis主从原理"/><br/>
当从节点下线一段时间后，再次恢复时，主节点会把下线这段时间的增量数据，一起同步给从节点。<br/>
如果要使用主从的话，主节点必须开启持久化，<strong>如果主节点没有开启持久化，当主节点宕机后，再次上线之后，主节点会将从节点的数据清空</strong>。</p>

<h2 id="toc_2">主从模式</h2>

<p>redis主从模式，一般都是一主2从，从节点不会太多，因为主从复制其实就是文件的上传和下载，如果从节点太多，主从复制的时候会占用很大一部分内网的带宽。<br/>
如果需要多个从节点，可以在从节点上继续配置主从模式，也就是从节点下还有从节点。<br/>
<img src="media/16057135385527/redis%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="redis主从模式"/></p>

<h2 id="toc_3">主从实践</h2>

<blockquote>
<p>在redis客户端，使用：info replication 命令，查看当前redis节点的主从配置信息。</p>
</blockquote>

<p>在redis.conf配置文件搜索 REPLICATION 找到配置主从的位置。配置主从时，只需要配置从节点即可，无需配置主节点。</p>

<h3 id="toc_4">配置从节点</h3>

<pre><code class="language-text"># 配置主节点的ip和端口
replicaof &lt;masterip&gt; &lt;masterport&gt;

# 配置主节点的登录密码（主节点没有配置密码，不需要配置该选项）
masterauth &lt;master-password&gt;

# 配置，只要是从节点，都开启，表示从节点只读，不进行写操作
replica-read-only yes
</code></pre>

<h3 id="toc_5">无磁盘化复制</h3>

<p>redis主从复制，默认是从节点将主节点保存在磁盘的rdb文件复制到从节点的磁盘，然后在将rdb文件恢复到内存。<br/>
无磁盘化复制，是将主节点的数据从主节点的内存中直接读取并写入从节点的内存，这样的传输方式，是使用socket的方式进行传输。<br/>
<img src="media/16057135385527/redis%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6.png" alt="redis无磁盘化复制"/></p>

<pre><code class="language-text"># 数据同步策略：无磁盘化复制，yes 开启，no 关闭
# 目前数据测试阶段，生产环境不建议使用 
repl-diskless-sync no
</code></pre>

<blockquote>
<p>redis数据同步策略有两种，一种是磁盘同步，也是默认的同步方式，redis新建一个进程，将数据写入rdb文件，这些rdb文件会定期向slave节点的磁盘同步。另一种数据同步的策略就是无磁盘化同步，master会创建一个新的进程，这个进程会向socket写入rdb文件，不向磁盘写入。如果服务器网络吞吐量比较大，可以使用第二种方式，提高效率。</p>
</blockquote>

<p>master节点可以配置一个时间，定期的向socket写入rdb文件。</p>

<pre><code class="language-text"># 无磁盘化同步间隔时间，单位（秒）
repl-diskless-sync-delay 5
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的持久化机制]]></title>
    <link href="jythons.github.io/16056250808598.html"/>
    <updated>2020-11-17T22:58:00+08:00</updated>
    <id>jythons.github.io/16056250808598.html</id>
    <content type="html"><![CDATA[
<p>Redis的数据是存放在缓存里面的，当计算机重启后，缓存内的数据会被清除，这时数据就会消失，因此，redis是可以支持持久化的，他可以根据策略将缓存中的数据存放到硬盘当中，保证数据的持久性。<br/>
Reids的持久化有两种方式，一种是RDB，另一种是AOF。下面分别介绍一下两种持久化机制的使用。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">RDB（Redis Database）</h2>

<p>RDB模式，是每隔一段时间以快照的方式去备份内存中的数据备份到磁盘上。备份的数据是开始备份那个时间点前的数据。</p>

<h3 id="toc_1">RDB优势</h3>

<ul>
<li>以单独的文件的形式去备份，他可以设置每个小时或者每天去备份一次，恢复的时候，可以根据不同的版本去恢复数据到内存当中。</li>
<li>方便灾后恢复数据，因为它只有一个文件，这个问价中的内容是完整的。</li>
<li>备份时，他是以子进程的方式进行备份的，没有占用主进程，保证服务可以正常运行。当子进程进行备份时，主进程不会进行磁盘的IO，这样可以保证数据的完整性。（？这时如果有数据进来怎么做）</li>
<li>当进行数据恢复的时候，可以快速的恢复比较大的数据集，相对于AOF，恢复的速度更快。</li>
</ul>

<h3 id="toc_2">RDB劣势</h3>

<ul>
<li>RDB是每隔一段时间去备份一次，当在备份的间隔时间内出现宕机，这时，在上次备份的时间点到宕机这个时间点之间的数据会丢失。如果不在乎数据的完整性，可以使用。</li>
<li>RDB在备份的时候，是fork一个子进程进行执行备份操作，这个子进程和主进程是相同的，如果数据集比较大，复制数据时，对于计算机的CPU消耗会比较大。</li>
<li>不能做到实时的备份。</li>
</ul>

<h3 id="toc_3">RDB配置</h3>

<p>打开Redis的配置文件 redis.conf，搜索SNAPSHOTTING，找到dir，这个就是备份时保存的文件路径。</p>

<pre><code class="language-text"># 如果至少有一个key发生变化，在900秒后就会保存一次快照
save 900 1
# 如果至少有10个key发生变化，那么在300秒后就回保存一次快照
save 300 10
# 如果至少有10000个key发生了变化，在60秒后就回保存一次快照
save 60 10000

# 如果保存的时候发生错误，就停止写入操作, 如果发生错误不停止写操作，就回出现数据
# 不一致的情况。
stop-writes-on-bgsave-error yes

# 这个是指是否使用压缩，如果使用压缩会占用CPU的性能，如果不使用压缩可以设置为no
# 使用 LZF 方式去压缩
rdbcompression yes

# 数据校验，使用CRC64去校验，使用校验，会有10%的性能消耗
rdbchecksum yes

# 备份文件名称
dbfilename dump.rdb
# 备份文件路径
dir /usr/local/redis/working
</code></pre>

<blockquote>
<p>总结：使用RDB的备份方式，比较适合大数据量的恢复操作，但是如果在最后一次保存之前出现异常，这时就回丢失数据，对数据的完整性没有保障，如果不在乎数据的完整性，可以使用RDB的持久化方式。</p>
</blockquote>

<h2 id="toc_4">AOF（append only fashion）</h2>

<p>aof是以日志的形式存在，只要数据发生变更，就会以追加的方式写入日志，由于aof的日志会越写越大，所以可以通过配置的方式去将日志进行切割。</p>

<h3 id="toc_5">AOF 优势</h3>

<ul>
<li>使用AOF可以使redis持久化更加健壮，他有三种方式去触发持久化
<ul>
<li>在关闭时触发</li>
<li>每秒触发（默认的方式）</li>
<li>发生写操作时触发</li>
</ul></li>
<li> 以日志的形式进行追加持久化</li>
<li> 日志内包含了所有的操作，便于redis的解析和恢复操作 </li>
</ul>

<h3 id="toc_6">AOF 劣势</h3>

<ul>
<li>因为是使用日志的方式，所以和RDB的快照文件相比，要大得多。</li>
<li>AOF持久化，每次写入都会有IO操作，因此频繁的IO操作，对计算机性能会有一定的消耗。</li>
<li>历史遗留的bug，AOF恢复的数据可能会有数据丢失。</li>
</ul>

<h3 id="toc_7">AOF 配置</h3>

<p>打开Redis的配置文件 redis.conf，搜索APPEND，下方的配置都是AOF配置相关的。<br/>
redis安装完毕后，默认的持久化方式是RDB模式</p>

<pre><code class="language-text"># 默认是关闭的， 启动AOF
appendonly yes

# AOF备份的文件名称
appendfilename &quot;appendonly.aof&quot;

# 同步策略
# 有写操作就同步
appendfsync always
# 每一秒
appendfsync everysec
# 关闭
appendfsync no

# 从写的时候不做写操作，否则会出现数据不一致的情况
no-appendfsync-on-rewrite no

# 重写机制，避免日志越来越大，AOF重写时，会执行flushALL命令，这个命令也会被记录到日志内，因此，在恢复的时候，需要将文件最后的flushALL命令删除，否则恢复之后是空的。
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
</code></pre>

<h2 id="toc_8">RDB 和 AOF 选择</h2>

<p>如果在可以接受在一段时间内他的缓存可以丢失的话，可以选择使用RDB模式。<br/>
如果对数据的实时性要求比较高，可以使用AOF的方式。<br/>
通常两个方法是一起使用，RDB作为冷备份，AOF用来做热备份，这样数据即使丢失最大就是在1s-2s。<br/>
redis在恢复的时候，是先去加载AOF日志进行恢复，如果AOF日志不存在，就回去使用RDB快照就恢复。这里有一个效率的问题，因为RDB是快照的方式，快照文件内记录的上一次备份时间点之前的所有数据，恢复的速度比较快，而AOF日志是记录了所有的操作命令，恢复的时候相对会比较慢，因此两个持久化的方法联合使用，不仅可以提高数据的安全性，也能提高数据恢复的速度。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[openssh-java]]></title>
    <link href="jythons.github.io/16056247075354.html"/>
    <updated>2020-11-17T22:51:47+08:00</updated>
    <id>jythons.github.io/16056247075354.html</id>
    <content type="html"><![CDATA[
<p><a href="https://github.com/apivovarov/openssh-java">https://github.com/apivovarov/openssh-java</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis发布与订阅]]></title>
    <link href="jythons.github.io/16055402422958.html"/>
    <updated>2020-11-16T23:24:02+08:00</updated>
    <id>jythons.github.io/16055402422958.html</id>
    <content type="html"><![CDATA[
<p>发布订阅，首先有一个发布者，然后有多个订阅者，每个订阅者需要去发布者那里去订阅消息，有了订阅之后，就相当于发布和订阅者之间有了一层绑定关系。当发布者发布了消息之后，所有的订阅者都可以收到这个消息。<br/>
<img src="media/16055402422958/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85.png" alt="redis发布和订阅"/></p>

<blockquote>
<p>例如：很多人关注了B站的up主，当up主发布了一条新的动态之后，所有的关注人员都会收到一条消息。这里的up主就相当于发布者，粉丝就相当于订阅者。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">redis实现发布订阅</h2>

<h3 id="toc_1">发布者</h3>

<pre><code class="language-text">publish chan message
</code></pre>

<blockquote>
<p>publish 发布消息，chan 通道，向chan通道发布消息，这里的chan和订阅者的ch是相同的，message 是发布的内容。</p>
</blockquote>

<h3 id="toc_2">订阅者</h3>

<pre><code class="language-text"># 订阅频道
subscribe ch [ch ...]
</code></pre>

<blockquote>
<p>subscribe 订阅，ch相当于频道，也就是发布者, 可以同时订阅多个频道。</p>
</blockquote>

<pre><code class="language-text"># 批量订阅，订阅所有moto开头的频道
psubscribe moto*
</code></pre>

<blockquote>
<p>redis只是实现的发布订阅的功能，生产上不建议使用redis做消息队列，专人专事，发布订阅的功能还是要使用mq去实现。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot整合redis]]></title>
    <link href="jythons.github.io/16055384723975.html"/>
    <updated>2020-11-16T22:54:32+08:00</updated>
    <id>jythons.github.io/16055384723975.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">添加依赖</h2>

<pre><code class="language-text">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">配置yml</h2>

<pre><code class="language-text">spring:
    redis:
        database: 0
        host: 192.168.1.111
        port: 6379
        password: psword
</code></pre>

<h2 id="toc_2">使用方法</h2>

<pre><code class="language-text">@ApiIgnore
@RestController
@RequestMapping(&quot;redis&quot;)
public class RedisController {

    @Autowired
    private RedisTemplate redisTemplate

    @GetMapping(&quot;/set&quot;)
    public Object set(String key, String value) {
        redisTemplate.opsForValue().set(key, value);
        return &quot;OK&quot;;
    }
    
    @GetMapping(&quot;/get&quot;)
    public String get(String key) {
        return (String)redisTemplate.opsForValue().get (key);
    }
    
    @GetMapping(&quot;/delete&quot;)
    public Object delete(String key) {
        redisTemplate.delete(key);
        return &quot;OK&quot;;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的数据类型]]></title>
    <link href="jythons.github.io/16050230410936.html"/>
    <updated>2020-11-10T23:44:01+08:00</updated>
    <id>jythons.github.io/16050230410936.html</id>
    <content type="html"><![CDATA[
<p>redis一共有五大数据类型，分别是：String、Hash、List、set、zset。下面分别介绍下每个数据类型的基本使用方法。<br/>
<a href="http://redisdoc.com">redis-doc</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">String数据类型</h2>

<blockquote>
<p>keys * 查看有多少个key，使用keys命令需要慎重，他是阻塞的，因此不要在正式环境使用。</p>
</blockquote>

<pre><code class="language-text"># 查看所有的key
keys *

# 查看所有 a 开头的key
keys a*

# 查看所有以e结尾的key
keys *e

# 查询key的类型，keyname是某个key的名字
type keyname
</code></pre>

<p><strong>set：</strong> 设置一个变量，变量存在更新</p>

<blockquote>
<p>例子：set key value</p>
</blockquote>

<p><strong>setnx：</strong> 设置一个变量，变量存在，不更新，不存在则添加 </p>

<blockquote>
<p>例子：setnx key value</p>
</blockquote>

<p><strong>ttl：</strong> （time to leave）查看key剩下的时间，返回 -1，表示永久保存</p>

<blockquote>
<p>例子：ttl key</p>
</blockquote>

<p><strong>expire：</strong> 为某个key设置过期时间</p>

<blockquote>
<p>例子：expire key second</p>
</blockquote>

<p><strong>set ex：</strong> 设置带有过期时间的key</p>

<blockquote>
<p>例子：set key value ex second</p>
</blockquote>

<p><strong>append：</strong> 字符串的拼接，在现有的key字符串后拼接一个：123</p>

<blockquote>
<p>例子：append key 123</p>
</blockquote>

<p><strong>strlen：</strong> 查看字符串的长度，查看key这个字付串的长度</p>

<blockquote>
<p>例子：strlen key</p>
</blockquote>

<p><strong>incr：</strong> 累加，在当前的key对应的value数值上 +1</p>

<blockquote>
<p>例子：incr key</p>
</blockquote>

<p><strong>decr：</strong> 累减，在当前的key对应的value数值上 -1</p>

<blockquote>
<p>例子：decr key</p>
</blockquote>

<p><strong>incrby：</strong> 带有步长的累加</p>

<blockquote>
<p>例子：incrby key 步长数值，【incrby key 10】</p>
</blockquote>

<p><strong>decrby：</strong> 带有步长的累减</p>

<blockquote>
<p>例子：decrby key 步长数值，【decrby key 10】</p>
</blockquote>

<p><strong>getrange：</strong> 截取字符串的一段返回</p>

<blockquote>
<p>例子：getrange key 1 2，获取key这个字符串的第1个字符到第2个字符，从0开始算</p>
</blockquote>

<p><strong>setrange：</strong> 替换字符串的某一段</p>

<blockquote>
<p>例子：setrange key 2 aa，从第2个字符开始，替换两个字符为aa，abcde -&gt; abaae</p>
</blockquote>

<p><strong>mset：</strong> 批量设置key</p>

<blockquote>
<p>mset key value [key value ...]，mset key1 value1 key2 value2</p>
</blockquote>

<p><strong>mget：</strong> 批量获取key</p>

<blockquote>
<p>mget key [key ...]，mget key1 key2</p>
</blockquote>

<p><strong>msetnx：</strong> 设置多个key，不能设置重复的key</p>

<blockquote>
<p>msetnx key1 value1 key2 value2 , 如果当前有key1，则本命令会执行失败，key2也不会保存</p>

<p>默认情况下，redis是有16个库，默认使用的是0，可以在配置文件内修改：databases参数来设置有多少个库。使用：select num（num表示库的下标），切换不同的库。</p>
</blockquote>

<p><strong>flushdb：</strong> 清除当前库里所有的数据<br/>
<strong>flushdball：</strong> 清除所有库里的数据</p>

<blockquote>
<p>flushdb和flushdball谨慎使用</p>
</blockquote>

<h2 id="toc_1">Hash数据类型</h2>

<p>hash数据类型，可以将结构化的数据存放到内存里面去。</p>

<blockquote>
<p>记忆：hash操作的命令都是以 h 开头，后面的基本和string命令相同。</p>
</blockquote>

<h3 id="toc_2">使用方法</h3>

<p><strong>hset key field value</strong>: 添加hash类型的数据</p>

<ul>
<li>hset 表示添加一个hash数据类型的数据</li>
<li>key 数据的key</li>
<li>field 数据的字段</li>
<li>value 字段对应的值</li>
</ul>

<blockquote>
<p>例子：想要存放一个 user:{&quot;name&quot;:&quot;xiaoming&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;man&quot;}<br/>
hset user name xiaoming<br/>
hset user age 18<br/>
hset user sex man</p>
</blockquote>

<p><strong>hget key field</strong>：获取hash类型的数据</p>

<ul>
<li>hset 表示添加一个hash数据类型的数据</li>
<li>key 数据的key</li>
<li>field 数据的字段</li>
</ul>

<blockquote>
<p>例子：获取 user:{&quot;name&quot;:&quot;xiaoming&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;man&quot;}数据的名字<br/>
hget user name</p>
</blockquote>

<p><strong>hmset key field value [field value ...]</strong>: 为某个key批量设置字段和值</p>

<p><strong>hmget key field [field ...]</strong>: 同时获取某个key下多个字段的值</p>

<p><strong>hgetall key</strong>：获取某个key下所有的字段和值</p>

<blockquote>
<p>hgetall 的返回值是field value field value 的形式。</p>
</blockquote>

<p><strong>hlen key</strong>：返回这个key下属性的数量<br/>
<strong>hkeys key</strong>：返回key下所有的属性（field）<br/>
<strong>hvals key</strong>：返回key下所有的值（value）<br/>
<strong>hincrby key field number</strong>：key下field字段的值累加number<br/>
<strong>hincrbyfloat key field number</strong>：key下field字段的值累加number，number可以是小数<br/>
<strong>hexists key field</strong>：判断key下是否存在field属性，存在返回1<br/>
<strong>hdel key field [field ...]</strong>: 删除key的field属性，支持同时删除多个属性</p>

<h2 id="toc_3">List数据类型</h2>

<p>List 是一个列表，可以理解为数组。<br/>
List操作的命令都以 l 开头。</p>

<h3 id="toc_4">使用方法</h3>

<p><strong>lpush key value [value ...]</strong>: 从左边添加一个list数据类型的数据<br/>
<strong>lrange key start end</strong>：获取key 的数据</p>

<blockquote>
<p>例子：lrange key 0 -1 获取列表key下的所有数据</p>
</blockquote>

<p><strong>rpush key value [value ...]</strong>: 从右边添加一个list数据类型的数据<br/>
<strong>lpop key</strong>：从左边取出一个值<br/>
<strong>rpop key</strong>：从右边取出一个值<br/>
<strong>llen key</strong>：获取key的长度<br/>
<strong>lindex key num</strong>：获取key列表的下标为num的value，该方法不会删除列表的数据<br/>
<strong>lset key num value</strong>：将key列表下标为num的值修改为value<br/>
<strong>linsert key before｜after pivot value</strong>：将value插入到key列表pivot数值的前面（before）或后面（after）<br/>
<strong>lrem key count value</strong>：删除key列表内count个value<br/>
<strong>ltrim key start stop</strong>：截取key列表从start开始到stop，包含start和stop</p>

<blockquote>
<p>del key 可以删除任何数据类型的key</p>
</blockquote>

<h2 id="toc_5">Set 数据类型（集合）</h2>

<p>set数据类型，会自动删除掉重复的数据。<br/>
set数据类型的操作命令都是以 s 开头。</p>

<h3 id="toc_6">使用方法</h3>

<p><strong>sadd key member [member ...]</strong>: 添加数据<br/>
<strong>smembers key</strong>：查看key集合下所有数据<br/>
<strong>scard key</strong>：查看key集合下数据的数量<br/>
<strong>sismember key member</strong>：查看member是否在key集合下<br/>
<strong>srem key member [member ...]</strong>: 删除key集合下member，支持同时删除多个<br/>
<strong>spop key [num]</strong>: 随机获取并删除key集合下一个或多个member，num表示删除个数<br/>
<strong>srandmembe key [num]</strong>：在key集合下随机抽取一个或多个数，num表示随机抽取个数<br/>
<strong>smove source destination member</strong>：从source集合移除member并添加到destinaction集合<br/>
<strong>sdiff key [key ...]</strong>: 获取key1集合内有的，在key2内没有的数据，key1相对于key2的差集<br/>
<strong>sinter key [key ...]</strong>: 获取key1和key2集合的交集<br/>
<strong>sunion key [key ...]</strong>: 获取key1和key2集合的并集</p>

<h2 id="toc_7">Zset 数据类型（有序集合）</h2>

<p>zset和set的区别是zset每一个member都有一个分数，这个分数是有序排列的。<br/>
zset的操作命令都是以 z 开头。</p>

<h3 id="toc_8">使用方法</h3>

<p><strong>zadd key score member [score member]</strong>：有序集合添加一个key 分数为score，值为member的数据，可以添加多个。<br/>
<strong>zrange key start stop [withscores]</strong>：查询key下的数据</p>

<blockquote>
<p>例1：zrange key 0 -1 # 查看所有<br/>
例2：zrange key 0 1  # 查看下标0到1的数据<br/>
例3：zrange key 0 -1 withscores # 查看数据和分数</p>
</blockquote>

<p><strong>zrank key member</strong>：查询key下的值为member的下标</p>

<blockquote>
<p>zrank key abc 查询key下值为abc的数据在key集合的位置，这里的位置不是分数。</p>
</blockquote>

<p><strong>zscore key member</strong>：查询key集合下值为member的分数</p>

<p><strong>zcard key</strong>：查询key集合下有多少个值</p>

<p><strong>zcount key min max</strong>：查询key集合下，分数大于等于min小于等于max的值有多少个</p>

<p><strong>zrangebyscore key min max [withscores] [limit offset count]</strong>：查看分数大于等于min小于等于max的值， 加上withscores，可以展示分数</p>

<blockquote>
<p>如果查询时不想要等于边界的数据，可以使用如下方式获取：<br/>
zrangebyscore key (min (max  这样就不会包含边界值了，上面的命令也可以使用。<br/>
limit 相当于mysql的分页，limit 1 2，在结果集从第一个开始获取2个返回。</p>
</blockquote>

<p><strong>zrem key member [member]</strong>：删除key集合下值为member的数据，可删除多个</p>

]]></content>
  </entry>
  
</feed>
