<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jythons小站]]></title>
  <link href="jythons.github.io/atom.xml" rel="self"/>
  <link href="jythons.github.io/"/>
  <updated>2020-11-12T23:43:36+08:00</updated>
  <id>jythons.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis发布与订阅]]></title>
    <link href="jythons.github.io/16055402422958.html"/>
    <updated>2020-11-16T23:24:02+08:00</updated>
    <id>jythons.github.io/16055402422958.html</id>
    <content type="html"><![CDATA[
<p>发布订阅，首先有一个发布者，然后有多个订阅者，每个订阅者需要去发布者那里去订阅消息，有了订阅之后，就相当于发布和订阅者之间有了一层绑定关系。当发布者发布了消息之后，所有的订阅者都可以收到这个消息。<br/>
<img src="media/16055402422958/redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85.png" alt="redis发布和订阅"/></p>

<blockquote>
<p>例如：很多人关注了B站的up主，当up主发布了一条新的动态之后，所有的关注人员都会收到一条消息。这里的up主就相当于发布者，粉丝就相当于订阅者。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">redis实现发布订阅</h2>

<h3 id="toc_1">发布者</h3>

<pre><code class="language-text">publish chan message
</code></pre>

<blockquote>
<p>publish 发布消息，chan 通道，向chan通道发布消息，这里的chan和订阅者的ch是相同的，message 是发布的内容。</p>
</blockquote>

<h3 id="toc_2">订阅者</h3>

<pre><code class="language-text"># 订阅频道
subscribe ch [ch ...]
</code></pre>

<blockquote>
<p>subscribe 订阅，ch相当于频道，也就是发布者, 可以同时订阅多个频道。</p>
</blockquote>

<pre><code class="language-text"># 批量订阅，订阅所有moto开头的频道
psubscribe moto*
</code></pre>

<blockquote>
<p>redis只是实现的发布订阅的功能，生产上不建议使用redis做消息队列，专人专事，发布订阅的功能还是要使用mq去实现。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot整合redis]]></title>
    <link href="jythons.github.io/16055384723975.html"/>
    <updated>2020-11-16T22:54:32+08:00</updated>
    <id>jythons.github.io/16055384723975.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">添加依赖</h2>

<pre><code class="language-text">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">配置yml</h2>

<pre><code class="language-text">spring:
    redis:
        database: 0
        host: 192.168.1.111
        port: 6379
        password: psword
</code></pre>

<h2 id="toc_2">使用方法</h2>

<pre><code class="language-text">@ApiIgnore
@RestController
@RequestMapping(&quot;redis&quot;)
public class RedisController {

    @Autowired
    private RedisTemplate redisTemplate

    @GetMapping(&quot;/set&quot;)
    public Object set(String key, String value) {
        redisTemplate.opsForValue().set(key, value);
        return &quot;OK&quot;;
    }
    
    @GetMapping(&quot;/get&quot;)
    public String get(String key) {
        return (String)redisTemplate.opsForValue().get (key);
    }
    
    @GetMapping(&quot;/delete&quot;)
    public Object delete(String key) {
        redisTemplate.delete(key);
        return &quot;OK&quot;;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的数据类型]]></title>
    <link href="jythons.github.io/16050230410936.html"/>
    <updated>2020-11-10T23:44:01+08:00</updated>
    <id>jythons.github.io/16050230410936.html</id>
    <content type="html"><![CDATA[
<p>redis一共有五大数据类型，分别是：String、Hash、List、set、zset。下面分别介绍下每个数据类型的基本使用方法。<br/>
<a href="http://redisdoc.com">redis-doc</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">String数据类型</h2>

<blockquote>
<p>keys * 查看有多少个key，使用keys命令需要慎重，他是阻塞的，因此不要在正式环境使用。</p>
</blockquote>

<pre><code class="language-text"># 查看所有的key
keys *

# 查看所有 a 开头的key
keys a*

# 查看所有以e结尾的key
keys *e

# 查询key的类型，keyname是某个key的名字
type keyname
</code></pre>

<p><strong>set：</strong> 设置一个变量，变量存在更新</p>

<blockquote>
<p>例子：set key value</p>
</blockquote>

<p><strong>setnx：</strong> 设置一个变量，变量存在，不更新，不存在则添加 </p>

<blockquote>
<p>例子：setnx key value</p>
</blockquote>

<p><strong>ttl：</strong> （time to leave）查看key剩下的时间，返回 -1，表示永久保存</p>

<blockquote>
<p>例子：ttl key</p>
</blockquote>

<p><strong>expire：</strong> 为某个key设置过期时间</p>

<blockquote>
<p>例子：expire key second</p>
</blockquote>

<p><strong>set ex：</strong> 设置带有过期时间的key</p>

<blockquote>
<p>例子：set key value ex second</p>
</blockquote>

<p><strong>append：</strong> 字符串的拼接，在现有的key字符串后拼接一个：123</p>

<blockquote>
<p>例子：append key 123</p>
</blockquote>

<p><strong>strlen：</strong> 查看字符串的长度，查看key这个字付串的长度</p>

<blockquote>
<p>例子：strlen key</p>
</blockquote>

<p><strong>incr：</strong> 累加，在当前的key对应的value数值上 +1</p>

<blockquote>
<p>例子：incr key</p>
</blockquote>

<p><strong>decr：</strong> 累减，在当前的key对应的value数值上 -1</p>

<blockquote>
<p>例子：decr key</p>
</blockquote>

<p><strong>incrby：</strong> 带有步长的累加</p>

<blockquote>
<p>例子：incrby key 步长数值，【incrby key 10】</p>
</blockquote>

<p><strong>decrby：</strong> 带有步长的累减</p>

<blockquote>
<p>例子：decrby key 步长数值，【decrby key 10】</p>
</blockquote>

<p><strong>getrange：</strong> 截取字符串的一段返回</p>

<blockquote>
<p>例子：getrange key 1 2，获取key这个字符串的第1个字符到第2个字符，从0开始算</p>
</blockquote>

<p><strong>setrange：</strong> 替换字符串的某一段</p>

<blockquote>
<p>例子：setrange key 2 aa，从第2个字符开始，替换两个字符为aa，abcde -&gt; abaae</p>
</blockquote>

<p><strong>mset：</strong> 批量设置key</p>

<blockquote>
<p>mset key value [key value ...]，mset key1 value1 key2 value2</p>
</blockquote>

<p><strong>mget：</strong> 批量获取key</p>

<blockquote>
<p>mget key [key ...]，mget key1 key2</p>
</blockquote>

<p><strong>msetnx：</strong> 设置多个key，不能设置重复的key</p>

<blockquote>
<p>msetnx key1 value1 key2 value2 , 如果当前有key1，则本命令会执行失败，key2也不会保存</p>

<p>默认情况下，redis是有16个库，默认使用的是0，可以在配置文件内修改：databases参数来设置有多少个库。使用：select num（num表示库的下标），切换不同的库。</p>
</blockquote>

<p><strong>flushdb：</strong> 清除当前库里所有的数据<br/>
<strong>flushdball：</strong> 清除所有库里的数据</p>

<blockquote>
<p>flushdb和flushdball谨慎使用</p>
</blockquote>

<h2 id="toc_1">Hash数据类型</h2>

<p>hash数据类型，可以将结构化的数据存放到内存里面去。</p>

<blockquote>
<p>记忆：hash操作的命令都是以 h 开头，后面的基本和string命令相同。</p>
</blockquote>

<h3 id="toc_2">使用方法</h3>

<p><strong>hset key field value</strong>: 添加hash类型的数据</p>

<ul>
<li>hset 表示添加一个hash数据类型的数据</li>
<li>key 数据的key</li>
<li>field 数据的字段</li>
<li>value 字段对应的值</li>
</ul>

<blockquote>
<p>例子：想要存放一个 user:{&quot;name&quot;:&quot;xiaoming&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;man&quot;}<br/>
hset user name xiaoming<br/>
hset user age 18<br/>
hset user sex man</p>
</blockquote>

<p><strong>hget key field</strong>：获取hash类型的数据</p>

<ul>
<li>hset 表示添加一个hash数据类型的数据</li>
<li>key 数据的key</li>
<li>field 数据的字段</li>
</ul>

<blockquote>
<p>例子：获取 user:{&quot;name&quot;:&quot;xiaoming&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;man&quot;}数据的名字<br/>
hget user name</p>
</blockquote>

<p><strong>hmset key field value [field value ...]</strong>: 为某个key批量设置字段和值</p>

<p><strong>hmget key field [field ...]</strong>: 同时获取某个key下多个字段的值</p>

<p><strong>hgetall key</strong>：获取某个key下所有的字段和值</p>

<blockquote>
<p>hgetall 的返回值是field value field value 的形式。</p>
</blockquote>

<p><strong>hlen key</strong>：返回这个key下属性的数量<br/>
<strong>hkeys key</strong>：返回key下所有的属性（field）<br/>
<strong>hvals key</strong>：返回key下所有的值（value）<br/>
<strong>hincrby key field number</strong>：key下field字段的值累加number<br/>
<strong>hincrbyfloat key field number</strong>：key下field字段的值累加number，number可以是小数<br/>
<strong>hexists key field</strong>：判断key下是否存在field属性，存在返回1<br/>
<strong>hdel key field [field ...]</strong>: 删除key的field属性，支持同时删除多个属性</p>

<h2 id="toc_3">List数据类型</h2>

<p>List 是一个列表，可以理解为数组。<br/>
List操作的命令都以 l 开头。</p>

<h3 id="toc_4">使用方法</h3>

<p><strong>lpush key value [value ...]</strong>: 从左边添加一个list数据类型的数据<br/>
<strong>lrange key start end</strong>：获取key 的数据</p>

<blockquote>
<p>例子：lrange key 0 -1 获取列表key下的所有数据</p>
</blockquote>

<p><strong>rpush key value [value ...]</strong>: 从右边添加一个list数据类型的数据<br/>
<strong>lpop key</strong>：从左边取出一个值<br/>
<strong>rpop key</strong>：从右边取出一个值<br/>
<strong>llen key</strong>：获取key的长度<br/>
<strong>lindex key num</strong>：获取key列表的下标为num的value，该方法不会删除列表的数据<br/>
<strong>lset key num value</strong>：将key列表下标为num的值修改为value<br/>
<strong>linsert key before｜after pivot value</strong>：将value插入到key列表pivot数值的前面（before）或后面（after）<br/>
<strong>lrem key count value</strong>：删除key列表内count个value<br/>
<strong>ltrim key start stop</strong>：截取key列表从start开始到stop，包含start和stop</p>

<blockquote>
<p>del key 可以删除任何数据类型的key</p>
</blockquote>

<h2 id="toc_5">Set 数据类型（集合）</h2>

<p>set数据类型，会自动删除掉重复的数据。<br/>
set数据类型的操作命令都是以 s 开头。</p>

<h3 id="toc_6">使用方法</h3>

<p><strong>sadd key member [member ...]</strong>: 添加数据<br/>
<strong>smembers key</strong>：查看key集合下所有数据<br/>
<strong>scard key</strong>：查看key集合下数据的数量<br/>
<strong>sismember key member</strong>：查看member是否在key集合下<br/>
<strong>srem key member [member ...]</strong>: 删除key集合下member，支持同时删除多个<br/>
<strong>spop key [num]</strong>: 随机获取并删除key集合下一个或多个member，num表示删除个数<br/>
<strong>srandmembe key [num]</strong>：在key集合下随机抽取一个或多个数，num表示随机抽取个数<br/>
<strong>smove source destination member</strong>：从source集合移除member并添加到destinaction集合<br/>
<strong>sdiff key [key ...]</strong>: 获取key1集合内有的，在key2内没有的数据，key1相对于key2的差集<br/>
<strong>sinter key [key ...]</strong>: 获取key1和key2集合的交集<br/>
<strong>sunion key [key ...]</strong>: 获取key1和key2集合的并集</p>

<h2 id="toc_7">Zset 数据类型（有序集合）</h2>

<p>zset和set的区别是zset每一个member都有一个分数，这个分数是有序排列的。<br/>
zset的操作命令都是以 z 开头。</p>

<h3 id="toc_8">使用方法</h3>

<p><strong>zadd key score member [score member]</strong>：有序集合添加一个key 分数为score，值为member的数据，可以添加多个。<br/>
<strong>zrange key start stop [withscores]</strong>：查询key下的数据</p>

<blockquote>
<p>例1：zrange key 0 -1 # 查看所有<br/>
例2：zrange key 0 1  # 查看下标0到1的数据<br/>
例3：zrange key 0 -1 withscores # 查看数据和分数</p>
</blockquote>

<p><strong>zrank key member</strong>：查询key下的值为member的下标</p>

<blockquote>
<p>zrank key abc 查询key下值为abc的数据在key集合的位置，这里的位置不是分数。</p>
</blockquote>

<p><strong>zscore key member</strong>：查询key集合下值为member的分数</p>

<p><strong>zcard key</strong>：查询key集合下有多少个值</p>

<p><strong>zcount key min max</strong>：查询key集合下，分数大于等于min小于等于max的值有多少个</p>

<p><strong>zrangebyscore key min max [withscores] [limit offset count]</strong>：查看分数大于等于min小于等于max的值， 加上withscores，可以展示分数</p>

<blockquote>
<p>如果查询时不想要等于边界的数据，可以使用如下方式获取：<br/>
zrangebyscore key (min (max  这样就不会包含边界值了，上面的命令也可以使用。<br/>
limit 相当于mysql的分页，limit 1 2，在结果集从第一个开始获取2个返回。</p>
</blockquote>

<p><strong>zrem key member [member]</strong>：删除key集合下值为member的数据，可删除多个</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis命令行客户端]]></title>
    <link href="jythons.github.io/16050224663931.html"/>
    <updated>2020-11-10T23:34:26+08:00</updated>
    <id>jythons.github.io/16050224663931.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基本使用</h2>

<p>启动redis命令行客户端：</p>

<pre><code class="language-text">redis-cli
</code></pre>

<span id="more"></span><!-- more -->

<blockquote>
<p>执行set name hello，如果提示：（error）NOAUTH Authentication required，表示没有权限，需要先输入密码，执行：auth password即可（passpword是配置文件设置的密码）。</p>
</blockquote>

<p>检查redis进程是否存活：</p>

<pre><code class="language-text">redis -a password ping
</code></pre>

<p>成功会返回：PONG</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的安装与配置]]></title>
    <link href="jythons.github.io/16049360201300.html"/>
    <updated>2020-11-09T23:33:40+08:00</updated>
    <id>jythons.github.io/16049360201300.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Redis安装</h2>

<p><a href="https://redis.io">Redis官网</a><br/>
在官网下载redis的安装压缩包，然后解压：</p>

<pre><code class="language-text">tar -zxvf redis-6.0.9.tar.gz
cd redis-6.0.9
</code></pre>

<p>这里需要注意的是，安装redis之前需要先安装他的一个依赖：</p>

<pre><code class="language-text">yum install gcc-c++
</code></pre>

<p>然后使用 make &amp;&amp; make install 安装；</p>

<pre><code class="language-text">make &amp;&amp; make install
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Redis配置</h2>

<p>安装好了以后，接下来需要先配置，然后才可以使用。<br/>
进入到安装目录下的 utils 文件夹：</p>

<pre><code class="language-text">cd utils
</code></pre>

<p>进去之后找到：redis_init_script文件，这个文件是redis的一个自动脚本，先复制一份：</p>

<pre><code class="language-text">cp redis_init_script /etc/init.d/
cd /etc/init.d/
</code></pre>

<p>然后再在 /usr/local/ 创建一个redis文件夹：</p>

<pre><code class="language-text">mkdir /usr/local/redis -p 
# 拷贝核心配置文件到这个目录下
cp redis.conf /usr/local/redis/
</code></pre>

<p>然后修改/usr/local/redis/这个目录下的配置文件：</p>

<pre><code class="language-text"># 找到daemonize，这个参数的意思是，redis启动后是在前台运行还是在后台运行
# yes表示在后台运行，no表示在前台运行（默认）
daemonize yes

# dir 这个参数是表示Redis的工作目录, 需要手动创建：working文件夹
dir /usr/local/redis/working

# bind 这个参数需要修改，如果不修改，只能在服务器本地使用，不能远程使用
bind 0.0.0.0

# requirepass 这个参数默认是注释掉的，表示不需要密码登录
requirepass 111111

# port 这个参数是redis启动的端口号，也可以在redis_init_script文件修改
port 6379

# pid 进程号
pid redis_6379.pid
</code></pre>

<p>配置好核心配置文件以后，接下来就要配置/etc/init.d/redis_init_script文件：</p>

<pre><code class="language-text"># 修改CONF的核心配置文件路径
CONF=&quot;/usr/local/redis/redis.conf&quot;
</code></pre>

<p>接下来就可以启动redis了</p>

<pre><code class="language-text">chmod 777 redis_init_script
# 启动
./redis_init_script start
# 停止 
./redis_init_script stop
</code></pre>

<h2 id="toc_2">配置redis开机自启动</h2>

<p>在redis_init_script文件内加上下面两段配置</p>

<pre><code class="language-text">#chkconfig：22345 10 90
#description Start and Stop redis
</code></pre>

<p>然后执行如下命令：</p>

<pre><code class="language-text">chkconfig redis_init_script on
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis简介]]></title>
    <link href="jythons.github.io/16049355266618.html"/>
    <updated>2020-11-09T23:25:26+08:00</updated>
    <id>jythons.github.io/16049355266618.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Redis优点</h2>

<ul>
<li>丰富的数据结构</li>
<li>持久化</li>
<li>主从同步、故障转移</li>
<li>内存数据库</li>
</ul>

<h2 id="toc_1">Redis缺点</h2>

<ul>
<li>单线程</li>
<li>单核</li>
</ul>

<blockquote>
<p>redis作者认为单核单线程比较简单安全。redis不仅可以做缓存，也可以做存储，因为它支持持久化，并且数据类型更加丰富。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_2">与Memcache对比</h2>

<h3 id="toc_3">Memcache优点</h3>

<ul>
<li>简单的 key-value 存储</li>
<li>内存使用率比较高</li>
<li>多核处理，多线程</li>
</ul>

<h3 id="toc_4">Memcache缺点</h3>

<ul>
<li>无法容灾</li>
<li>不支持持久化</li>
</ul>

<blockquote>
<p>小数据量速度会比Memcache要快，大数据量Memcache更有优势，因为Memcache支持多核多线程处理，Redis是单核单线程的。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建Keepalived + LVS + Nginx 高可用集群负载均衡]]></title>
    <link href="jythons.github.io/16048487950121.html"/>
    <updated>2020-11-08T23:19:55+08:00</updated>
    <id>jythons.github.io/16048487950121.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16048487950121/%E5%8D%95%E4%B8%AA%E5%85%A5%E5%8F%A3%E5%9B%BE%E7%89%87.png" alt="单个入口图片"/></p>

<p>当前配置的只有一个LVS负载均衡服务器，当这个服务器挂掉之后，后面所有的请求都无法到达上游RS服务器，整个服务就回挂掉，因此就需要在添加一台备用机，使用Keepalived实现主备自动切换，保证服务24小时可用。如下图所示：<br/>
<img src="media/16048487950121/%E4%B8%BB%E5%A4%87LVS%E5%88%87%E6%8D%A2.png" alt="主备LVS切换"/><br/>
使用Keepalived不但可以使LVS主备自动切换，还可以检测RS服务器是否可用，如果有挂掉的RS服务器，则会自动剔除，避免将请求转发到挂掉的RS服务器。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">在LVS服务器上配置Keepalived</h2>

<p>首先安装Keepalived，安装方法见：<a href="/16042148155872.html">Keepalived安装</a><br/>
然后编辑：keepalived.conf 配置文件</p>

<pre><code class="language-text">! 全局配置
global_defs {
   ! 路由ID：当前安装Keepalived节点主机的标识符，全局唯一
   router_id LVS_151
}

! 计算机节点，基于vrrp协议的一个实例
vrrp_instance VI_1 {
    ! 表示状态，当前服务器的nginx的主节点，MASTER/BACKUP
    state MASTER
    ! 当前实例绑定的网卡
    interface ens33
    ! 保证主备节点一致即可
    virtual_router_id 41
    ! 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选
    priority 100
    ! 主备之间同步检查时间间隔，单位秒
    advert_int 1
    ! 认证权限密码。防止非法节点进入
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    
    ! 虚拟出来的ip，可以有多个（vip）
    virtual_ipaddress {
        192.168.1.150
    }
}
# 这里是LVS的配置，virtual_server是LVS服务，real_server是服务节点
virtual_server 192.168.1.150 80 {
    # 健康检查的时间，单位：秒
    delay_loop 6
    # 配置负载均衡的算法，默认是轮询，lb就是负载均衡的意思
    lb_algo rr
    # 设置LVS模式 NAT｜TUN｜DR
    lb_kind DR
    # 多少秒内多次请求转发到同一个服务器，设置会话持久化的时间
    persistence_timeout 50
    # 协议 -t
    protocol TCP

    # 负载均衡的真实服务器，也就是nginx节点的具体的真实IP地址
    real_server 192.168.1.171 80 {
        # 轮询的默认权重配比设置为1
        weight 1
        # 设置健康检查
        TCP_CHECK {
            # 检查80端口
            connect_port 80
            # 超时时间 单位：秒
            connect_timeout 2 
            # 重试次数
            nb_get_retry 2
            # 重试间隔时间，单位：秒
            delay_before_retry 3
        }
    }
    real_server 192.168.1.172 80 {
        # 轮询的默认权重配比设置为1
        weight 1
        # 设置健康检查
        TCP_CHECK {
            # 检查80端口
            connect_port 80
            # 超时时间 单位：秒
            connect_timeout 2 
            # 重试次数
            nb_get_retry 2
            # 重试间隔时间，单位：秒
            delay_before_retry 3
        }
    }
}
</code></pre>

<p>配置好以上配置后，清除ipvsadm的配置</p>

<pre><code class="language-text">ipvsadm -C
</code></pre>

<p>这样ipvs的配置就全被清除了，接下来重启Keepalived服务</p>

<pre><code class="language-text">systemctl restart keepalived
</code></pre>

<p>查看ipvs的配置是否成功：</p>

<pre><code class="language-text">ipvsadm -Ln
</code></pre>

<blockquote>
<p>如果没有输出内容，可能是keepalived的配置文件错误。<br/>
配置好MASTER之后，再将master的keepalived配置复制到backup节点配置一下，<br/>
修改router_id LVS_152, state BACKUP, priority 50, 权重官方建议和MASTER相差50即可</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS的持久化机制]]></title>
    <link href="jythons.github.io/16048478935893.html"/>
    <updated>2020-11-08T23:04:53+08:00</updated>
    <id>jythons.github.io/16048478935893.html</id>
    <content type="html"><![CDATA[
<p>如果一个用户短时间内多次提交请求，那么他的请求都会转发到第一次请求的RS服务器，这个时间段默认是300秒。<br/>
配置方式：</p>

<pre><code class="language-text"># 详细信息使用：man ipvsadm
ipvsadm -E -t 192.168.1.150:80 -s rr -p [time] 
</code></pre>

<blockquote>
<p>-E 编辑服务，-t 服务地址</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>通过以上配置，在访问的时候，经过time秒后，访问依然只请求到了一个服务器，这是因为有一个tcp或udp的链接超时时间，可以通过以下配置，修改超时时间。</p>

<pre><code class="language-text">ipvsadm --set 1 1 1
</code></pre>

<blockquote>
<p>ipvsadm -Lnc 查看是否有链接</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 LVS-DR 模式]]></title>
    <link href="jythons.github.io/16043322529866.html"/>
    <updated>2020-11-02T23:50:52+08:00</updated>
    <id>jythons.github.io/16043322529866.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">服务器与 IP 约定</h2>

<p><img src="media/16043322529866/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EIP%E7%BA%A6%E5%AE%9A.png" alt="服务器与IP约定"/></p>

<p>首先需要有一个LVS，LVS需要有两个IP，分别是：DIP（Direct IP）和VIP (Virtual IP)；DIP就是内网IP，用于与内网上游服务器通信使用；VIP是虚拟IP，用于客户端交互使用。<br/>
然后上游服务器Nginx，Nginx服务器需要配置两个IP，分别是：RIP（Real Server IP）和VIP (Virtual IP); RIP也是内网IP，VIP也是虚拟IP，用户的请求处理完毕，通过VIP返回给客户端；Nginx服务器的VIP要和LVS的虚拟IP保持一致。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">开始搭建 LVS</h2>

<h3 id="toc_2">配置虚拟IP</h3>

<p>第一步，首先要关闭服务器网络配置管理器，如果不关闭，可能会引起接口网络的冲突，因为是在本地使用虚拟机的关系。</p>

<pre><code class="language-text"># 关闭网络配置管理器
systemctl stop NetworkManager
systemctl disable NetworkManager
</code></pre>

<p>同样 Nginx 服务器也需要关闭网络配置管理器。</p>

<p>第二步，构建LVS的IP。</p>

<pre><code class="language-text"># 进入网卡配置文件目录
cd /etc/sysconfig/network-script/
# 拷贝一份网卡配置文件，起一个别名
cp ifcfg-ens33 ifcfg-ens33:1
</code></pre>

<p>然后配置ifcfg-ens33:1文件, 配置如下：</p>

<pre><code class="language-text">BOOTPROTO=static
# 与网卡名称要保持统一
DEVICE=ens33:1
ONBOOT=yes
IPADDR=192.168.1.150
NETMASK=255.255.255.0
</code></pre>

<p>配置好网卡后，重启网卡：</p>

<pre><code class="language-text">service network restart
ip addr # 查看IP地址是否生效
</code></pre>

<p>到这里，虚拟IP就配置好了。</p>

<h3 id="toc_3">配置集群管理工具</h3>

<p>虚拟IP配置好了以后，接下来就需要配置集群管理工具。</p>

<blockquote>
<p>ipvs 是lvs自带的工具，ipvsadm需要安装。</p>
</blockquote>

<p>安装ipvsadm：</p>

<pre><code class="language-text">yum install ipvsadm
</code></pre>

<p>接下来执行如下命令查看集群列表</p>

<pre><code class="language-text">ipvsadm -Ln
</code></pre>

<blockquote>
<p>阿里云云服务器不支持虚拟IP配置，需要购买他们的负载均衡服务，腾讯云服务器支持配置虚拟IP，但是要额外的去购买的，因为是建立在网卡之上的，需要使用成本的，腾讯云支持虚拟IP的最大数量是10个。</p>
</blockquote>

<h3 id="toc_4">配置RIS节点的IP</h3>

<p>LVS服务器配置好以后，接下来去配置RIS节点服务器的IP，也就是Nginx所在的服务器。<br/>
首先也需要配置一个虚拟IP，这个IP用于返回数据报文。<br/>
首先进入到网卡配置文件所在的目录：</p>

<pre><code class="language-text"># 进入网卡配置文件目录
cd /etc/sysconfig/network-script/
</code></pre>

<p>在这个目录下，有一个 ifcfg-lo 配置文件，这个是服务器本地环回接口，我们要构建一个虚拟IP，这个IP不能被用户访问到，只是在返回报文时使用。<br/>
复制一份 ifcfg-lo 配置文件为：ifcfg-lo:1。</p>

<pre><code class="language-text">cp ifcfg-lo ifcfg-lo:1
</code></pre>

<p>修改成如下配置：</p>

<pre><code class="language-text"># BOOTPROTO=static
# 与网卡名称要保持统一
DEVICE=lo:1
ONBOOT=yes
IPADDR=192.168.1.150
NETMASK=255.255.255.255
NETWORK=127.0.0.1
BROADCAST=127.255.255.255
NAME=loopback
</code></pre>

<h3 id="toc_5">RS服务器配置ARP</h3>

<h4 id="toc_6">arp-ignore: ARP 响应级别（处理请求）</h4>

<ul>
<li>0: 只要本机配置了ip，就能响应请求（在lvs是不适用的）</li>
<li>1: 请求的目标地址到达对应的网络接口，才会响应请求（这个才是需要的）</li>
</ul>

<blockquote>
<p>配置LVS时，RS服务器需要配置一个环回地址，这个地址不能处理请求，所以要将 arp-ihnore配置成 1，请求哪个ip，哪个IP才会处理请求。</p>
</blockquote>

<h4 id="toc_7">arp-announce：ARP通告行为（返回响应）</h4>

<ul>
<li>0: 本机上任何网络接口都向外通告，所有的网卡都能接受到通告（在lvs是不适用的）</li>
<li>1: 尽可能避免本网卡与不匹配的目标进行通告（在lvs是不适用的，要一定，不能尽可能）</li>
<li>2: 只在本网卡通告（这个才是需要的） </li>
</ul>

<blockquote>
<p>RS 服务器的环回IP是用来响应客户端请求的，所以不能使用其他IP来返回，必须使用环回地址返回，因为客户端请求的是VIP，所以接收请求也必须使用RS服务器上和VIP相同的环回IP才能使客户端识别。</p>
</blockquote>

<h3 id="toc_8">配置RS服务器APR</h3>

<pre><code class="language-text"># 打开配置文件
vim /etc/sysctl.conf
# 配置如下内容：
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_announce = 2
# 保存后，刷新一下网卡
sysctl -p
</code></pre>

<blockquote>
<p>all：表示所有网卡<br/>
default：表示默认网卡<br/>
lo：环回网卡</p>
</blockquote>

<h3 id="toc_9">RS 服务器配置路由</h3>

<pre><code class="language-text"># 临时配置路由，开机回失效，需要添加到开机启动配置文件内
route add -host 192.168.1.150 dev lo:1
# 永久添加, 执行如下命令
echo &quot;route add -host 192.168.1.150 dev lo:1&quot; &gt;&gt; /etc/rc.local
</code></pre>

<blockquote>
<p>通过192.168.1.150这个地址去接收请求，然后交给lo:1这个网卡去处理<br/>
使用 route -n 查看路由</p>
</blockquote>

<h3 id="toc_10">使用ipvsadm配置集群规则</h3>

<h4 id="toc_11">配置LVS服务以及节点</h4>

<pre><code class="language-text"># 添加服务
ipvsadm -A -t 192.168.1.150:80 -s rr
# 查看配置列表
ipvsadm -Ln
</code></pre>

<blockquote>
<p>添加一个服务，-A 添加一个服务，-t tcp,添加服务地址，-s 负载均衡算法，rr 轮询，轮询是负载均衡里用的比较多的算法。</p>
</blockquote>

<pre><code class="language-text"># 构建服务
ipvsadm -a -t 192.168.1.150:80 -r 192.168.1.171:80 -g
</code></pre>

<blockquote>
<p>配置服务，-a 添加一个服务节点，-t 服务地址，表示为哪个服务地址添加节点，-r real server 的意思，写RS服务器的IP地址, -g 表示是DR模式。</p>
</blockquote>

<h4 id="toc_12">验证DR模式</h4>

<pre><code class="language-text"># 查看LVS运行状态
ipvsadm -Ln
</code></pre>

<blockquote>
<p>DR 模式是LVS只负责接收请求，返回请求交给RS，通过上面的命令，查看InPkts有数据，而OutPkts为0，说明DR模式生效了。 </p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS的三种模式]]></title>
    <link href="jythons.github.io/16043306453976.html"/>
    <updated>2020-11-02T23:24:05+08:00</updated>
    <id>jythons.github.io/16043306453976.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>NAT，基于网络地址转换；<br/>
TUN，基于IP隧道的模式；<br/>
DR，直接路由模式。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">LVS 模式之 NAT</h2>

<p>网络地址转换<br/>
<img src="media/16043306453976/NAT%E6%A8%A1%E5%9E%8B.png" alt="NAT模型"/></p>

<p>NAT模型和Nginx相同，LVS需要同时处理请求和返回，这样在流量比较大的情况下，会出现负载过高的问题。<br/>
NAT模型对外使用虚拟IP，与上游服务器交互使用的是私网IP，上游服务器是不能与客户端直接交互的。</p>

<h2 id="toc_1">LVS 模式之 TUN</h2>

<p>隧道模式<br/>
<img src="media/16043306453976/TUN%E6%A8%A1%E5%9E%8B.png" alt="TUN模型"/></p>

<p>TUN是基于隧道的通信方式，所有的服务器都需要通过隧道通信，使用TUN模型，所有的响应都不会经过LVS，在上游服务器处理完请求后，他会直接将响应返回给客户端，可以减轻上行请求的压力，大大提高了并发以及吞吐量。但是这个模型有一个硬性的要求，每一个服务器节点都要配备一个网卡，这样，每个服务器几点就回暴漏在公网。</p>

<h2 id="toc_2">LVS 模式之 DR</h2>

<p>直接路由模式<br/>
<img src="media/16043306453976/DR%E6%A8%A1%E5%9E%8B.png" alt="DR模型"/></p>

<p>DR模型和TUN模型相似，LVS只处理请求，响应由每个服务器节点返回，但是不同的是，服务器节点返回响应统一由路由返回，这样上游的服务器节点就不会暴漏在公网上面，大大提高的安全性。<br/>
用户通过虚拟IP访问，响应时，在路由出也构建一个虚拟IP来统一返回响应。对于用户来说，通过虚拟IP，将服务器给隐藏了起来</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS简介]]></title>
    <link href="jythons.github.io/16042488055175.html"/>
    <updated>2020-11-02T00:40:05+08:00</updated>
    <id>jythons.github.io/16042488055175.html</id>
    <content type="html"><![CDATA[
<p>LVS (Linux Virtual Server)，linux虚拟服务，他是由章文嵩博士主导的开源的负载均衡项目，LVS（ipvs）被Linux系统默认集成到了Linux内核中；<br/>
LVS也是一个负载均衡调度器，是一个四层的负载均衡（Nginx是7层的负载均衡，是在内容层对请求报文的负载均衡），四层负载均衡是一个基于IP+Port的负载均衡。<br/>
<a href="http://www.linux-vs.org/index/html">官网地址</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">LVS 网络拓扑图</h2>

<p><img src="media/16042488055175/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%8811.06.28.png" alt="截屏2020-11-02 下午11.06.28"/></p>

<h2 id="toc_1">为什么要使用 LVS + Nginx</h2>

<ul>
<li>LVS基于四层，工作效率高，接收到请求之后可以直接转发，要比单个Nginx的性能要高几十倍</li>
<li>单个Nginx承受不了压力，需要集群</li>
<li>LVS充当Nginx集群的调度者，LVS是不会处理请求的报文的，因此承受负载的能力会更高</li>
<li>Nginx接受请求来回，LVS可以直接受不响应</li>
</ul>

<h3 id="toc_2">Nginx网络拓扑图</h3>

<p><img src="media/16042488055175/Nginx%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="Nginx网络拓扑图"/><br/>
Nginx在实现负载均衡时，需要处理请求，并处理返回结果，因此会大大增加Nginx的负载，举个例子，如果一个饭店进来吃饭和吃完饭出去的人都走同一个门，那么这个门会非常的堵。</p>

<h3 id="toc_3">LVS网络拓扑图</h3>

<p><img src="media/16042488055175/LVS%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="LVS网络拓扑图"/><br/>
LVS实现负载均衡时，LVS接受所有的请求，将请求转发给上游服务器，上游服务器处理完请求，经过LVS的某种模式，直接返回给客户端，这样大大减少了LVS的负载，并提高了整个系统的并发能力。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keepalived 双机热备原理]]></title>
    <link href="jythons.github.io/16042463644403.html"/>
    <updated>2020-11-01T23:59:24+08:00</updated>
    <id>jythons.github.io/16042463644403.html</id>
    <content type="html"><![CDATA[
<p>双机主备的缺点：如果在主节点比较稳定，一直没有问题的话，这时备用节点的服务器一直不使用，这样会造成成本开销加大。<br/>
因此就要采用双机热备的策略，将备用节点利用起来，在没有问题时，备用节点用来做其他的事情。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">原理图</h2>

<p><img src="media/16042463644403/keeplived%E5%8F%8C%E4%B8%BB%E7%83%AD%E5%A4%87.png" alt="keeplived双主热备"/></p>

<blockquote>
<p>关于DNS轮训，可以在腾讯云或者阿里云控制台配置。</p>
</blockquote>

<h2 id="toc_1">原理</h2>

<p>当主节点没有问题时，两个节点各自维护自己的服务请求，当其中一个节点发生故障时，发生故障的节点虚拟IP会与另一个没有故障的 Nginx 绑定，将请求发送到没有故障的节点，当故障恢复后，在自动绑定回原来节点的Nginx。这里就不再区分主节点和备用节点，两个节点互为主备。</p>

<h2 id="toc_2">实现</h2>

<blockquote>
<p>规则：以一个虚拟IP分组归为同一个路由</p>
</blockquote>

<p><strong>主节点配置：</strong></p>

<pre><code class="language-text">global_defs {
    router_id keep_171
}

vrrp_script check_nginx_alive {
    script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot;
    ! 每隔两秒运行上一行脚本
    interval 2
    ! 如果脚本运行成功，则升级权重+10
    weight 10
    ! 如果脚本运行失败，则降级权重-10
    # weight -10
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        check_nginx_alive # 追踪 nginx 脚本
    }
    virtual_ipaddress {
        192.168.1.161
    }
}

vrrp_instance VI_2 {
    state BACKUP
    interface ens33
    virtual_router_id 52
    priority 80
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.162
    }
}
</code></pre>

<p><strong>备用节点配置：</strong></p>

<pre><code class="language-text">global_defs {
    router_id keep_171
}

vrrp_script check_nginx_alive {
    script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot;
    ! 每隔两秒运行上一行脚本
    interval 2
    ! 如果脚本运行成功，则升级权重+10
    weight 10
    ! 如果脚本运行失败，则降级权重-10
    # weight -10
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 51
    priority 80
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.161
    }
}

vrrp_instance VI_2 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        check_nginx_alive # 追踪 nginx 脚本
    }
    virtual_ipaddress {
        192.168.1.162
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keepalived配置Nginx自动重启]]></title>
    <link href="jythons.github.io/16042438752112.html"/>
    <updated>2020-11-01T23:17:55+08:00</updated>
    <id>jythons.github.io/16042438752112.html</id>
    <content type="html"><![CDATA[
<p>当主节点 Nginx 服务挂掉之后，Keepalived 还会继续挂在主节点上运行，这时请求网站时，网站是不能访问的，这时需要将 Nginx 重新启动，否则网站是不能访问的，如果 Nginx 不能再次启动，这时就需要将 Keepalived 主节点切换成备用节点。这时就需要写一个脚本，来实现这个功能。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Keepalived自动重启Nginx服务</h2>

<blockquote>
<p>将自动重启 Nginx 服务的脚本写在 Keepalived 主配置文件同级目录下（/etc/keepalived）</p>
</blockquote>

<p><strong>检测 Nginx 服务是否存活脚本如下：</strong></p>

<pre><code class="language-text">file_name check_nginx_alive_or_not.sh

#!/bin/bash
A=`ps -C nginx --no-header | wc -l`
# 判断 nginx 是否宕机，如果宕机了，尝试重启
if [ $A -eq 0 ];then
    /usr/local/nginx/sbin/nginx
    # 等待一小会再次检查 nginx，如果没有启动成功，则停止Keepalived，使其启动备用机
    sleep 3
    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then
        killall keepalived
    fi
fi
</code></pre>

<p><strong>然后到 Keepalived 主配置文件内添加一个脚本的监听。</strong></p>

<blockquote>
<p>在主配置文件中定一个脚本：vrrp_script，然后在 VI_1 节点配置调用。<br/>
配置完成后重启Keepalived：systemctl restart keepalived</p>
</blockquote>

<pre><code class="language-text">! 全局配置
global_defs {
   ! 配置切换通知的email
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   ! 配置发件人
   notification_email_from Alexandre.Cassen@firewall.loc
   ! 配置邮箱服务器地址
   smtp_server 192.168.200.1
   ! 配置链接邮箱服务器的超时时间
   smtp_connect_timeout 30
   ! 路由ID：当前安装Keepalived节点主机的标识符，全局唯一
   router_id LVS_DEVEL
   ! 全局vrrp协议配置
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

! 添加自动启动Nginx监听
vrrp_script check_nginx_alive {
    script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot;
    ! 每隔两秒运行上一行脚本
    interval 2
    ! 如果脚本运行成功，则升级权重+10
    weight 10
    ! 如果脚本运行失败，则降级权重-10
    # weight -10
}

! 计算机节点，基于vrrp协议的一个实例
vrrp_instance VI_1 {
    ! 表示状态，当前服务器的nginx的主节点，MASTER/BACKUP
    state MASTER
    ! 当前实例绑定的网卡
    interface eth0
    ! 保证主备节点一致即可
    virtual_router_id 51
    ! 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选
    priority 100
    ! 主备之间同步检查时间间隔，单位秒
    advert_int 2
    ! 认证权限密码。防止非法节点进入
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    
    track_script {
        check_nginx_alive # 追踪 nginx 脚本
    }
    
    ! 虚拟出来的ip，可以有多个（vip）
    virtual_ipaddress {
        192.168.200.16
        192.168.200.17
        192.168.200.18
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keepalived]]></title>
    <link href="jythons.github.io/16042148155872.html"/>
    <updated>2020-11-01T15:13:35+08:00</updated>
    <id>jythons.github.io/16042148155872.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">IP规划</h2>

<p><img src="media/16042148155872/keepalived-IP%E8%A7%84%E5%88%92.png" alt="keepalived-IP规划"/></p>

<blockquote>
<p>keepalived官网<a href="https://www.keepalived.org/index.html">地址</a></p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装Keepalived</h2>

<ol>
<li><a href="https://www.keepalived.org/software/keepalived-2.1.5.tar.gz">下载安装包</a></li>
<li>解压：tar -zxvf keepalived-2.1.5.tar.gz</li>
<li>cd keepalived-2.1.5</li>
<li>./configure --prefix=/usr/local/keepalived --sysconf=/etc</li>
<li>make &amp;&amp; make install</li>
</ol>

<blockquote>
<p>--prefix: 安装目录；--sysconf: 同步核心配置到/etc目录下，<code>/etc/keepalived/keepalived.conf</code>，固定位置，改成其他位置则keepalived启动不了，<code>/var/log/messages</code>中会报错。<br/>
配置过程中可能会出现警告信息，如下所示：<br/>
<code>*** WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-devel ...</code><br/>
解决办法：安装libnl/libnl-3依赖，<code>yum -y install libnl libnl-devel</code>, 然后重新安装步骤的第4步和第五部一下，此时OK。</p>
</blockquote>

<h2 id="toc_2">Keepalived 核心配置文件</h2>

<pre><code class="language-text">! 全局配置
global_defs {
   ! 配置切换通知的email
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   ! 配置发件人
   notification_email_from Alexandre.Cassen@firewall.loc
   ! 配置邮箱服务器地址
   smtp_server 192.168.200.1
   ! 配置链接邮箱服务器的超时时间
   smtp_connect_timeout 30
   ! 路由ID：当前安装Keepalived节点主机的标识符，全局唯一
   router_id LVS_DEVEL
   ! 全局vrrp协议配置
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}
! 计算机节点，基于vrrp协议的一个实例
vrrp_instance VI_1 {
    ! 表示状态，当前服务器的nginx的主节点，MASTER/BACKUP
    state MASTER
    ! 当前实例绑定的网卡
    interface eth0
    ! 保证主备节点一致即可
    virtual_router_id 51
    ! 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选
    priority 100
    ! 主备之间同步检查时间间隔，单位秒
    advert_int 2
    ! 认证权限密码。防止非法节点进入
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    ! 虚拟出来的ip，可以有多个（vip）
    virtual_ipaddress {
        192.168.200.16
        192.168.200.17
        192.168.200.18
    }
}
! 下方都是虚拟主机，这里不需要可以删除
virtual_server 192.168.200.100 443 {
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.201.100 443 {
        weight 1
        SSL_GET {
            url {
              path /
              digest ff20ad2481f97b1754ef3e12ecd3a9cc
            }
            url {
              path /mrtg/
              digest 9b3a0c85a887a256d6939da88aabd8cd
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
}

virtual_server 10.10.10.2 1358 {
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    sorry_server 192.168.200.200 1358

    real_server 192.168.200.2 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
    
    real_server 192.168.200.3 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
}

virtual_server 10.10.10.3 1358 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.200.4 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
    
    real_server 192.168.200.5 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
}
</code></pre>

<h2 id="toc_3">启动 Keepalived</h2>

<pre><code class="language-text">cd /usr/local/keepalived/sbin
./keepalived
</code></pre>

<h2 id="toc_4">关闭 Keepalived</h2>

<p><code>ps -ef | grep keepalived</code>, 查出进程号，直接kill -9 进程ID。</p>

<h2 id="toc_5">Keepalived 注册为系统服务</h2>

<p>进入Keepalived的安装目录（安装包解压后的文件夹内），里面有一个keepalived文件夹，进入，里面有一个 etc 文件夹。拷贝 etc/init.d/keepalived 到系统目录/etc/init.d/ 文件夹下。</p>

<pre><code class="language-shell">cp ./keepalived/etc/init.d/keepalived /etc/init.d/
cp ./keepalived/etc/sysconfig/keepalived /etc/sysconfig/
</code></pre>

<p>然后刷新系统服务，使刚加进去的服务生效。</p>

<pre><code class="language-text">systemctl daemon-reload
</code></pre>

<p>这样就可以在系统服务中使用Keepalived了。</p>

<h3 id="toc_6">系统中使用Keepalived</h3>

<pre><code class="language-text">systemctl start keepalived.service    # 启动Keepalived服务
systemctl stop keepalived.service     # 停止Keepalived服务
systemctl restart keepalived.service  # 重新启动Keepalived服务
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx高可用集群架构]]></title>
    <link href="jythons.github.io/16042095103845.html"/>
    <updated>2020-11-01T13:45:10+08:00</updated>
    <id>jythons.github.io/16042095103845.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">高可用 HA（High Availability）</h2>

<h3 id="toc_1">Keepalived双机主备原理</h3>

<p>反向代理服务器，分为主节点和一个备用节点，当主节点挂掉之后，自动切换为备用节点。<br/>
<img src="media/16042095103845/HA%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="HA高可用"/><br/>
<span id="more"></span><!-- more --></p>

<h3 id="toc_2">Keepalived概念</h3>

<ul>
<li>解决单点故障，不单单是在nginx上使用，也可以在redis等集群服务上使用。</li>
<li>组件免费</li>
<li>可以实现高可用HA机制</li>
<li>基于VRRP协议</li>
</ul>

<h3 id="toc_3">虚拟路由冗余协议 VRRP</h3>

<blockquote>
<p>VRRP即虚拟路由冗余协议(Virtual Router Redundancy Protocol)，它是为了避免路由器出现单点故障的一种容错协议。 </p>
</blockquote>

<ul>
<li>解决内网单机故障的路由协议</li>
<li>通过该协议，可以构建有多个路由器 MASTER BACKUP</li>
<li>虚拟IP - VIP（Virtual IP Address）</li>
</ul>

<h3 id="toc_4">Keepalived双机主备原理</h3>

<p>用户以前是直接请求到Nginx，有了Keepalived之后，用户先请求到虚拟IP，由于虚拟IP是和Nginx的Master节点绑定的，所以，请求会到达Master节点的Nginx。<br/><br/>
<img src="media/16042095103845/%E8%99%9A%E6%8B%9FIP%E8%AE%BF%E9%97%AEMaster-nginx.png" alt="虚拟IP访问Master-nginx"/></p>

<p>虚拟IP会对Nginx做心跳检测，如果主节点Nginx挂掉之后，虚拟IP就会和Nginx的备用节点绑定，用户的请求还是先请求到虚拟IP，然后请求到备用节点的Nginx。<br/>
<img src="media/16042095103845/%E8%99%9A%E6%8B%9FIP%E8%AE%BF%E9%97%AE%E5%A4%87%E7%94%A8Nginx%E8%8A%82%E7%82%B9.png" alt="虚拟IP访问备用Nginx节点"/></p>

<blockquote>
<p>不管是使用多个还是一个备用节点，要保证备用节点的配置和主节点的服务器配置是相同的。<br/>
例如，主节点可以同时处理1000个请求，备用节点可以同时处理100个请求，当主节点挂掉之后，请求会全部打到备用节点，这时由于备用节点的配置比较低，不能同时处理100个以上的请求，因此，备用节点会瞬间挂掉。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动静分离的那些事]]></title>
    <link href="jythons.github.io/16042031909226.html"/>
    <updated>2020-11-01T11:59:50+08:00</updated>
    <id>jythons.github.io/16042031909226.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">动静分离的特点</h2>

<h3 id="toc_1">分布式</h3>

<p>动静分离的本质就是分布式，把动态接口和静态的资源分开这样的话就可以减少后台服务器的压力，提高了静态资源的访问速度，因为静态资源是可以被缓存的，一旦有了缓存的话，用户访问的速度就回更快。后端就不需要再去渲染页面，以往的开发，html、jsp是需要服务器去渲染的，现在采用动静分离，静态资源都是交给客户端去渲染。<br/>
<span id="more"></span><!-- more --></p>

<h3 id="toc_2">前后端解耦</h3>

<p>前后端分离的开发模式，前后端分开开发，分开部署。</p>

<h3 id="toc_3">静态归Nginx</h3>

<p>静态资源，例如：js、css、html等静态资源都交由Nginx管理，从Nginx里面去读去和加载静态资源的。</p>

<h3 id="toc_4">接口的服务化</h3>

<p>因为是动静分离，所以接口都是单独的去部署，通过集群去部署，这样就可以封装一些接口和数据，让前端去调用。</p>

<h2 id="toc_5">动静分离</h2>

<h3 id="toc_6">静态数据</h3>

<p>例如像css、js、html、images、audios、videos这些，如果需要修改，Nginx会根据最后一次的修改时间来刷新数据。</p>

<h3 id="toc_7">动态数据</h3>

<p>动态数据往往都是以一个接口的形式去请求，动态数据可能第一次去请求和第二次去请求获得的结果是一样的。例如文章，文章列表数据。</p>

<h2 id="toc_8">动静分离的方式</h2>

<h3 id="toc_9">CDN</h3>

<p>CDN是一个内容分发网络，他可以根据客户端的地域去选择最近的服务器来获取资源，加速访问速度。</p>

<h3 id="toc_10">Nginx</h3>

<p>根据url来判断请求的是静态资源还是动态资源，如果是请求的静态资源，就将请求转发到静态资源集群，如果请求的动态资源，就将请求转发到动态资源的上游服务器。</p>

<h2 id="toc_11">动静分离的问题</h2>

<h3 id="toc_12">跨域</h3>

<p>解决方式：</p>

<ul>
<li>SpringBoot</li>
<li>Nginx</li>
<li>jsonp</li>
</ul>

<h3 id="toc_13">分布式会话</h3>

<ul>
<li>分布式缓存中间件，例如：redis</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx中配置SSL证书]]></title>
    <link href="jythons.github.io/16041606361898.html"/>
    <updated>2020-11-01T00:10:36+08:00</updated>
    <id>jythons.github.io/16041606361898.html</id>
    <content type="html"><![CDATA[
<p>Nginx默认访问使用的是http协议，如果要使用https协议，需要为网站配置SSL证书，因为https是安全的，对传输的数据进行了加密。使用https，必须要有一个域名，并且域名需要备案之后才可以使用。<br/>
申请完SSL证书后，会得到两个文件，一个是.crt后缀的文件是证书文件，还有一个是.key文件，是密钥文件。<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">新增Nginx的SSL模块</h2>

<blockquote>
<p>要在nginx中配置https，就必须安装ssl模块，也就是：http_ssl_module。</p>
</blockquote>

<ul>
<li>进入到nginx的解压目录：/home/jythons/package/nginx-1.18.0</li>
<li>新增ssl模块（原来的那些模块需要保留）</li>
</ul>

<pre><code class="language-text">./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi \
--with-http_ssl_module

</code></pre>

<ul>
<li>编译和安装</li>
</ul>

<pre><code class="language-text">make
make install
</code></pre>

<h2 id="toc_1">Nginx配置HTTPS</h2>

<ul>
<li>把ssl证书 *.crt和私钥 *.key 拷贝到/usr/local/nginx/conf 目录中。</li>
<li>新增server监听443端口</li>
</ul>

<pre><code class="language-text">#配置上游服务器
upstream tomcats {
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

server {
    listen 443;
    server_name www.tomcats.com;
    
    # 开启ssl
    ssl on;
    # 配置ssl证书
    ssl_certificate 1_www.tomcats.com_bundle.crt;
    # 配置证书密钥
    ssl_certificate_key 1_www.tomcats.com.key;
    
    # ssl会话cache
    ssl_session_cache shared:SSL:1m;
    # ssl会话超时时间
    ssl_session_timeout 5m;
    
    # 配置加密套件，写法遵循openssl标准
    ssl_protocols TLSv1.1 TLSv1.2;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
    ssl_prefer_server_ciphers on;
    
    location / {
        proxy_pass http://tomcats/;
        index index.html index.htm;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx控制浏览器缓存]]></title>
    <link href="jythons.github.io/16038978992618.html"/>
    <updated>2020-10-28T23:11:39+08:00</updated>
    <id>jythons.github.io/16038978992618.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">原理图</h2>

<p><img src="media/16038978992618/Nginx%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.png" alt="Nginx控制浏览器缓存"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">设置缓存的指令：expires指令</h2>

<p>expires [time] 设置多少秒后缓存过期；例：expires 10s<br/>
expires @[time] 设置到那个时间点缓存过期；例：expires @22h30m<br/>
expires -[time] 表示在现在缓存的多长时间以前就过期；例：expires -1h<br/>
expires epoch 表示不去缓存<br/>
expires off 表示Nginx端关闭缓存，在浏览器上不会体现出来；<br/>
expires max 表示缓存的一个最大的时间，表示永不过期。</p>

<h2 id="toc_2">在Nginx中的使用方法</h2>

<pre><code class="language-text">location /static {
    alias /home/static;
    expires 10s;
}
</code></pre>

<p><img src="media/16038978992618/header%E6%98%BE%E7%A4%BA%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.png" alt="header显示过期时间"/></p>

<h2 id="toc_3">Nginx反向代理缓存</h2>

<pre><code class="language-text">#配置上游服务器
upstream tomcats {
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

# 设置缓存保存的目录, 
# keys_zone 设置共享内存空间，和大小
# max_size 设置缓存大小
# inactive 超过此时间，则缓存自动清理, 8h:8小时，8m:8分钟，8s:8秒
# use_temp_path 关闭临时目录，临时目录会对nginx造成性能影响
proxy_cache_path /usr/local/nginx/upsteam_cache keys_zone=mycache:5m max_size=1g inactive=8h use_temp_path=off;

server {
        listen 80;
        server_name www.tomcats.com;
        
        # 开启并且使用缓存，mycache对应上方proxy_cache_path配置
        proxy_cache mycache;
        # 针对200和304状态码，设置缓存过期时间
        proxy_cache_valid 200 304 8h
        
        location / {
                proxy_pass http://tomcats;
        }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[负载均衡之url_hash]]></title>
    <link href="jythons.github.io/16038966099434.html"/>
    <updated>2020-10-28T22:50:09+08:00</updated>
    <id>jythons.github.io/16038966099434.html</id>
    <content type="html"><![CDATA[
<p>从字面上可以看出，他是基于URL的hash算法，根据URL获得的hash值将请求分配到不同的节点上<br/>
<img src="media/16038966099434/URL-hash.png" alt="URL-hash"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Nginx配置</h2>

<pre><code class="language-text">upstream tomcats {
        hash $request_uri; 
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

server {
        listen 80;
        server_name www.tomcats.com;

        location / {
                proxy_pass http://tomcats;
        }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[负载均衡之ip_hash]]></title>
    <link href="jythons.github.io/16038139816578.html"/>
    <updated>2020-10-27T23:53:01+08:00</updated>
    <id>jythons.github.io/16038139816578.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">hash算法</h2>

<blockquote>
<p>hash(ip) % node_counts = index<br/>
通过对客户端IP进行哈希然后根据上方公式分配到对应的服务器处理，之后的每次请求，只要客户端的IP没有变化，所有的请求都会请求到这台服务器上。<br/>
由于nginx的ip_hash算法是根据IP的前三个数值进行的hash，所以内网使用时，只会访问同一台服务器上。如果有人进行不正当的大量请求，这时所有的请求都会转发到同一台服务器上，这时会造成这台服务器的负载升高。<br/>
当使用ip_hash的方式进行负载均衡时，如果要临时移除一台服务器时，不能直接将这个server删除，要将这要服务器标记为down。<br/>
该算法，在增加或减少节点时，都需要重新计算。</p>
</blockquote>

<span id="more"></span><!-- more -->

<pre><code class="language-text">upstream tomcats {
        ip_hash; # 使用ip_hash的方式实现负载均衡
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}
</code></pre>

]]></content>
  </entry>
  
</feed>
