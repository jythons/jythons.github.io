<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jythons小站]]></title>
  <link href="jythons.github.io/atom.xml" rel="self"/>
  <link href="jythons.github.io/"/>
  <updated>2020-11-09T00:19:31+08:00</updated>
  <id>jythons.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[搭建Keepalived + LVS + Nginx 高可用集群负载均衡]]></title>
    <link href="jythons.github.io/16048487950121.html"/>
    <updated>2020-11-08T23:19:55+08:00</updated>
    <id>jythons.github.io/16048487950121.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16048487950121/%E5%8D%95%E4%B8%AA%E5%85%A5%E5%8F%A3%E5%9B%BE%E7%89%87.png" alt="单个入口图片"/></p>

<p>当前配置的只有一个LVS负载均衡服务器，当这个服务器挂掉之后，后面所有的请求都无法到达上游RS服务器，整个服务就回挂掉，因此就需要在添加一台备用机，使用Keepalived实现主备自动切换，保证服务24小时可用。如下图所示：<br/>
<img src="media/16048487950121/%E4%B8%BB%E5%A4%87LVS%E5%88%87%E6%8D%A2.png" alt="主备LVS切换"/><br/>
使用Keepalived不但可以使LVS主备自动切换，还可以检测RS服务器是否可用，如果有挂掉的RS服务器，则会自动剔除，避免将请求转发到挂掉的RS服务器。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">在LVS服务器上配置Keepalived</h2>

<p>首先安装Keepalived，安装方法见：<a href="/16042148155872.html">Keepalived安装</a><br/>
然后编辑：keepalived.conf 配置文件</p>

<pre><code class="language-text">! 全局配置
global_defs {
   ! 路由ID：当前安装Keepalived节点主机的标识符，全局唯一
   router_id LVS_151
}

! 计算机节点，基于vrrp协议的一个实例
vrrp_instance VI_1 {
    ! 表示状态，当前服务器的nginx的主节点，MASTER/BACKUP
    state MASTER
    ! 当前实例绑定的网卡
    interface ens33
    ! 保证主备节点一致即可
    virtual_router_id 41
    ! 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选
    priority 100
    ! 主备之间同步检查时间间隔，单位秒
    advert_int 1
    ! 认证权限密码。防止非法节点进入
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    
    ! 虚拟出来的ip，可以有多个（vip）
    virtual_ipaddress {
        192.168.1.150
    }
}
# 这里是LVS的配置，virtual_server是LVS服务，real_server是服务节点
virtual_server 192.168.1.150 80 {
    # 健康检查的时间，单位：秒
    delay_loop 6
    # 配置负载均衡的算法，默认是轮询，lb就是负载均衡的意思
    lb_algo rr
    # 设置LVS模式 NAT｜TUN｜DR
    lb_kind DR
    # 多少秒内多次请求转发到同一个服务器，设置会话持久化的时间
    persistence_timeout 50
    # 协议 -t
    protocol TCP

    # 负载均衡的真实服务器，也就是nginx节点的具体的真实IP地址
    real_server 192.168.1.171 80 {
        # 轮询的默认权重配比设置为1
        weight 1
        # 设置健康检查
        TCP_CHECK {
            # 检查80端口
            connect_port 80
            # 超时时间 单位：秒
            connect_timeout 2 
            # 重试次数
            nb_get_retry 2
            # 重试间隔时间，单位：秒
            delay_before_retry 3
        }
    }
    real_server 192.168.1.172 80 {
        # 轮询的默认权重配比设置为1
        weight 1
        # 设置健康检查
        TCP_CHECK {
            # 检查80端口
            connect_port 80
            # 超时时间 单位：秒
            connect_timeout 2 
            # 重试次数
            nb_get_retry 2
            # 重试间隔时间，单位：秒
            delay_before_retry 3
        }
    }
}
</code></pre>

<p>配置好以上配置后，清除ipvsadm的配置</p>

<pre><code class="language-text">ipvsadm -C
</code></pre>

<p>这样ipvs的配置就全被清除了，接下来重启Keepalived服务</p>

<pre><code class="language-text">systemctl restart keepalived
</code></pre>

<p>查看ipvs的配置是否成功：</p>

<pre><code class="language-text">ipvsadm -Ln
</code></pre>

<blockquote>
<p>如果没有输出内容，可能是keepalived的配置文件错误。<br/>
配置好MASTER之后，再将master的keepalived配置复制到backup节点配置一下，<br/>
修改router_id LVS_152, state BACKUP, priority 50, 权重官方建议和MASTER相差50即可</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS的持久化机制]]></title>
    <link href="jythons.github.io/16048478935893.html"/>
    <updated>2020-11-08T23:04:53+08:00</updated>
    <id>jythons.github.io/16048478935893.html</id>
    <content type="html"><![CDATA[
<p>如果一个用户短时间内多次提交请求，那么他的请求都会转发到第一次请求的RS服务器，这个时间段默认是300秒。<br/>
配置方式：</p>

<pre><code class="language-text"># 详细信息使用：man ipvsadm
ipvsadm -E -t 192.168.1.150:80 -s rr -p [time] 
</code></pre>

<blockquote>
<p>-E 编辑服务，-t 服务地址</p>
</blockquote>

<span id="more"></span><!-- more -->

<p>通过以上配置，在访问的时候，经过time秒后，访问依然只请求到了一个服务器，这是因为有一个tcp或udp的链接超时时间，可以通过以下配置，修改超时时间。</p>

<pre><code class="language-text">ipvsadm --set 1 1 1
</code></pre>

<blockquote>
<p>ipvsadm -Lnc 查看是否有链接</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 LVS-DR 模式]]></title>
    <link href="jythons.github.io/16043322529866.html"/>
    <updated>2020-11-02T23:50:52+08:00</updated>
    <id>jythons.github.io/16043322529866.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">服务器与 IP 约定</h2>

<p><img src="media/16043322529866/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EIP%E7%BA%A6%E5%AE%9A.png" alt="服务器与IP约定"/></p>

<p>首先需要有一个LVS，LVS需要有两个IP，分别是：DIP（Direct IP）和VIP (Virtual IP)；DIP就是内网IP，用于与内网上游服务器通信使用；VIP是虚拟IP，用于客户端交互使用。<br/>
然后上游服务器Nginx，Nginx服务器需要配置两个IP，分别是：RIP（Real Server IP）和VIP (Virtual IP); RIP也是内网IP，VIP也是虚拟IP，用户的请求处理完毕，通过VIP返回给客户端；Nginx服务器的VIP要和LVS的虚拟IP保持一致。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">开始搭建 LVS</h2>

<h3 id="toc_2">配置虚拟IP</h3>

<p>第一步，首先要关闭服务器网络配置管理器，如果不关闭，可能会引起接口网络的冲突，因为是在本地使用虚拟机的关系。</p>

<pre><code class="language-text"># 关闭网络配置管理器
systemctl stop NetworkManager
systemctl disable NetworkManager
</code></pre>

<p>同样 Nginx 服务器也需要关闭网络配置管理器。</p>

<p>第二步，构建LVS的IP。</p>

<pre><code class="language-text"># 进入网卡配置文件目录
cd /etc/sysconfig/network-script/
# 拷贝一份网卡配置文件，起一个别名
cp ifcfg-ens33 ifcfg-ens33:1
</code></pre>

<p>然后配置ifcfg-ens33:1文件, 配置如下：</p>

<pre><code class="language-text">BOOTPROTO=static
# 与网卡名称要保持统一
DEVICE=ens33:1
ONBOOT=yes
IPADDR=192.168.1.150
NETMASK=255.255.255.0
</code></pre>

<p>配置好网卡后，重启网卡：</p>

<pre><code class="language-text">service network restart
ip addr # 查看IP地址是否生效
</code></pre>

<p>到这里，虚拟IP就配置好了。</p>

<h3 id="toc_3">配置集群管理工具</h3>

<p>虚拟IP配置好了以后，接下来就需要配置集群管理工具。</p>

<blockquote>
<p>ipvs 是lvs自带的工具，ipvsadm需要安装。</p>
</blockquote>

<p>安装ipvsadm：</p>

<pre><code class="language-text">yum install ipvsadm
</code></pre>

<p>接下来执行如下命令查看集群列表</p>

<pre><code class="language-text">ipvsadm -Ln
</code></pre>

<blockquote>
<p>阿里云云服务器不支持虚拟IP配置，需要购买他们的负载均衡服务，腾讯云服务器支持配置虚拟IP，但是要额外的去购买的，因为是建立在网卡之上的，需要使用成本的，腾讯云支持虚拟IP的最大数量是10个。</p>
</blockquote>

<h3 id="toc_4">配置RIS节点的IP</h3>

<p>LVS服务器配置好以后，接下来去配置RIS节点服务器的IP，也就是Nginx所在的服务器。<br/>
首先也需要配置一个虚拟IP，这个IP用于返回数据报文。<br/>
首先进入到网卡配置文件所在的目录：</p>

<pre><code class="language-text"># 进入网卡配置文件目录
cd /etc/sysconfig/network-script/
</code></pre>

<p>在这个目录下，有一个 ifcfg-lo 配置文件，这个是服务器本地环回接口，我们要构建一个虚拟IP，这个IP不能被用户访问到，只是在返回报文时使用。<br/>
复制一份 ifcfg-lo 配置文件为：ifcfg-lo:1。</p>

<pre><code class="language-text">cp ifcfg-lo ifcfg-lo:1
</code></pre>

<p>修改成如下配置：</p>

<pre><code class="language-text"># BOOTPROTO=static
# 与网卡名称要保持统一
DEVICE=lo:1
ONBOOT=yes
IPADDR=192.168.1.150
NETMASK=255.255.255.255
NETWORK=127.0.0.1
BROADCAST=127.255.255.255
NAME=loopback
</code></pre>

<h3 id="toc_5">RS服务器配置ARP</h3>

<h4 id="toc_6">arp-ignore: ARP 响应级别（处理请求）</h4>

<ul>
<li>0: 只要本机配置了ip，就能响应请求（在lvs是不适用的）</li>
<li>1: 请求的目标地址到达对应的网络接口，才会响应请求（这个才是需要的）</li>
</ul>

<blockquote>
<p>配置LVS时，RS服务器需要配置一个环回地址，这个地址不能处理请求，所以要将 arp-ihnore配置成 1，请求哪个ip，哪个IP才会处理请求。</p>
</blockquote>

<h4 id="toc_7">arp-announce：ARP通告行为（返回响应）</h4>

<ul>
<li>0: 本机上任何网络接口都向外通告，所有的网卡都能接受到通告（在lvs是不适用的）</li>
<li>1: 尽可能避免本网卡与不匹配的目标进行通告（在lvs是不适用的，要一定，不能尽可能）</li>
<li>2: 只在本网卡通告（这个才是需要的） </li>
</ul>

<blockquote>
<p>RS 服务器的环回IP是用来响应客户端请求的，所以不能使用其他IP来返回，必须使用环回地址返回，因为客户端请求的是VIP，所以接收请求也必须使用RS服务器上和VIP相同的环回IP才能使客户端识别。</p>
</blockquote>

<h3 id="toc_8">配置RS服务器APR</h3>

<pre><code class="language-text"># 打开配置文件
vim /etc/sysctl.conf
# 配置如下内容：
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_announce = 2
# 保存后，刷新一下网卡
sysctl -p
</code></pre>

<blockquote>
<p>all：表示所有网卡<br/>
default：表示默认网卡<br/>
lo：环回网卡</p>
</blockquote>

<h3 id="toc_9">RS 服务器配置路由</h3>

<pre><code class="language-text"># 临时配置路由，开机回失效，需要添加到开机启动配置文件内
route add -host 192.168.1.150 dev lo:1
# 永久添加, 执行如下命令
echo &quot;route add -host 192.168.1.150 dev lo:1&quot; &gt;&gt; /etc/rc.local
</code></pre>

<blockquote>
<p>通过192.168.1.150这个地址去接收请求，然后交给lo:1这个网卡去处理<br/>
使用 route -n 查看路由</p>
</blockquote>

<h3 id="toc_10">使用ipvsadm配置集群规则</h3>

<h4 id="toc_11">配置LVS服务以及节点</h4>

<pre><code class="language-text"># 添加服务
ipvsadm -A -t 192.168.1.150:80 -s rr
# 查看配置列表
ipvsadm -Ln
</code></pre>

<blockquote>
<p>添加一个服务，-A 添加一个服务，-t tcp,添加服务地址，-s 负载均衡算法，rr 轮询，轮询是负载均衡里用的比较多的算法。</p>
</blockquote>

<pre><code class="language-text"># 构建服务
ipvsadm -a -t 192.168.1.150:80 -r 192.168.1.171:80 -g
</code></pre>

<blockquote>
<p>配置服务，-a 添加一个服务节点，-t 服务地址，表示为哪个服务地址添加节点，-r real server 的意思，写RS服务器的IP地址, -g 表示是DR模式。</p>
</blockquote>

<h4 id="toc_12">验证DR模式</h4>

<pre><code class="language-text"># 查看LVS运行状态
ipvsadm -Ln
</code></pre>

<blockquote>
<p>DR 模式是LVS只负责接收请求，返回请求交给RS，通过上面的命令，查看InPkts有数据，而OutPkts为0，说明DR模式生效了。 </p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS的三种模式]]></title>
    <link href="jythons.github.io/16043306453976.html"/>
    <updated>2020-11-02T23:24:05+08:00</updated>
    <id>jythons.github.io/16043306453976.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>NAT，基于网络地址转换；<br/>
TUN，基于IP隧道的模式；<br/>
DR，直接路由模式。</p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_0">LVS 模式之 NAT</h2>

<p>网络地址转换<br/>
<img src="media/16043306453976/NAT%E6%A8%A1%E5%9E%8B.png" alt="NAT模型"/></p>

<p>NAT模型和Nginx相同，LVS需要同时处理请求和返回，这样在流量比较大的情况下，会出现负载过高的问题。<br/>
NAT模型对外使用虚拟IP，与上游服务器交互使用的是私网IP，上游服务器是不能与客户端直接交互的。</p>

<h2 id="toc_1">LVS 模式之 TUN</h2>

<p>隧道模式<br/>
<img src="media/16043306453976/TUN%E6%A8%A1%E5%9E%8B.png" alt="TUN模型"/></p>

<p>TUN是基于隧道的通信方式，所有的服务器都需要通过隧道通信，使用TUN模型，所有的响应都不会经过LVS，在上游服务器处理完请求后，他会直接将响应返回给客户端，可以减轻上行请求的压力，大大提高了并发以及吞吐量。但是这个模型有一个硬性的要求，每一个服务器节点都要配备一个网卡，这样，每个服务器几点就回暴漏在公网。</p>

<h2 id="toc_2">LVS 模式之 DR</h2>

<p>直接路由模式<br/>
<img src="media/16043306453976/DR%E6%A8%A1%E5%9E%8B.png" alt="DR模型"/></p>

<p>DR模型和TUN模型相似，LVS只处理请求，响应由每个服务器节点返回，但是不同的是，服务器节点返回响应统一由路由返回，这样上游的服务器节点就不会暴漏在公网上面，大大提高的安全性。<br/>
用户通过虚拟IP访问，响应时，在路由出也构建一个虚拟IP来统一返回响应。对于用户来说，通过虚拟IP，将服务器给隐藏了起来</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LVS简介]]></title>
    <link href="jythons.github.io/16042488055175.html"/>
    <updated>2020-11-02T00:40:05+08:00</updated>
    <id>jythons.github.io/16042488055175.html</id>
    <content type="html"><![CDATA[
<p>LVS (Linux Virtual Server)，linux虚拟服务，他是由章文嵩博士主导的开源的负载均衡项目，LVS（ipvs）被Linux系统默认集成到了Linux内核中；<br/>
LVS也是一个负载均衡调度器，是一个四层的负载均衡（Nginx是7层的负载均衡，是在内容层对请求报文的负载均衡），四层负载均衡是一个基于IP+Port的负载均衡。<br/>
<a href="http://www.linux-vs.org/index/html">官网地址</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">LVS 网络拓扑图</h2>

<p><img src="media/16042488055175/%E6%88%AA%E5%B1%8F2020-11-02%20%E4%B8%8B%E5%8D%8811.06.28.png" alt="截屏2020-11-02 下午11.06.28"/></p>

<h2 id="toc_1">为什么要使用 LVS + Nginx</h2>

<ul>
<li>LVS基于四层，工作效率高，接收到请求之后可以直接转发，要比单个Nginx的性能要高几十倍</li>
<li>单个Nginx承受不了压力，需要集群</li>
<li>LVS充当Nginx集群的调度者，LVS是不会处理请求的报文的，因此承受负载的能力会更高</li>
<li>Nginx接受请求来回，LVS可以直接受不响应</li>
</ul>

<h3 id="toc_2">Nginx网络拓扑图</h3>

<p><img src="media/16042488055175/Nginx%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="Nginx网络拓扑图"/><br/>
Nginx在实现负载均衡时，需要处理请求，并处理返回结果，因此会大大增加Nginx的负载，举个例子，如果一个饭店进来吃饭和吃完饭出去的人都走同一个门，那么这个门会非常的堵。</p>

<h3 id="toc_3">LVS网络拓扑图</h3>

<p><img src="media/16042488055175/LVS%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="LVS网络拓扑图"/><br/>
LVS实现负载均衡时，LVS接受所有的请求，将请求转发给上游服务器，上游服务器处理完请求，经过LVS的某种模式，直接返回给客户端，这样大大减少了LVS的负载，并提高了整个系统的并发能力。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keepalived 双机热备原理]]></title>
    <link href="jythons.github.io/16042463644403.html"/>
    <updated>2020-11-01T23:59:24+08:00</updated>
    <id>jythons.github.io/16042463644403.html</id>
    <content type="html"><![CDATA[
<p>双机主备的缺点：如果在主节点比较稳定，一直没有问题的话，这时备用节点的服务器一直不使用，这样会造成成本开销加大。<br/>
因此就要采用双机热备的策略，将备用节点利用起来，在没有问题时，备用节点用来做其他的事情。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">原理图</h2>

<p><img src="media/16042463644403/keeplived%E5%8F%8C%E4%B8%BB%E7%83%AD%E5%A4%87.png" alt="keeplived双主热备"/></p>

<blockquote>
<p>关于DNS轮训，可以在腾讯云或者阿里云控制台配置。</p>
</blockquote>

<h2 id="toc_1">原理</h2>

<p>当主节点没有问题时，两个节点各自维护自己的服务请求，当其中一个节点发生故障时，发生故障的节点虚拟IP会与另一个没有故障的 Nginx 绑定，将请求发送到没有故障的节点，当故障恢复后，在自动绑定回原来节点的Nginx。这里就不再区分主节点和备用节点，两个节点互为主备。</p>

<h2 id="toc_2">实现</h2>

<blockquote>
<p>规则：以一个虚拟IP分组归为同一个路由</p>
</blockquote>

<p><strong>主节点配置：</strong></p>

<pre><code class="language-text">global_defs {
    router_id keep_171
}

vrrp_script check_nginx_alive {
    script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot;
    ! 每隔两秒运行上一行脚本
    interval 2
    ! 如果脚本运行成功，则升级权重+10
    weight 10
    ! 如果脚本运行失败，则降级权重-10
    # weight -10
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        check_nginx_alive # 追踪 nginx 脚本
    }
    virtual_ipaddress {
        192.168.1.161
    }
}

vrrp_instance VI_2 {
    state BACKUP
    interface ens33
    virtual_router_id 52
    priority 80
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.162
    }
}
</code></pre>

<p><strong>备用节点配置：</strong></p>

<pre><code class="language-text">global_defs {
    router_id keep_171
}

vrrp_script check_nginx_alive {
    script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot;
    ! 每隔两秒运行上一行脚本
    interval 2
    ! 如果脚本运行成功，则升级权重+10
    weight 10
    ! 如果脚本运行失败，则降级权重-10
    # weight -10
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 51
    priority 80
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.161
    }
}

vrrp_instance VI_2 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        check_nginx_alive # 追踪 nginx 脚本
    }
    virtual_ipaddress {
        192.168.1.162
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keepalived配置Nginx自动重启]]></title>
    <link href="jythons.github.io/16042438752112.html"/>
    <updated>2020-11-01T23:17:55+08:00</updated>
    <id>jythons.github.io/16042438752112.html</id>
    <content type="html"><![CDATA[
<p>当主节点 Nginx 服务挂掉之后，Keepalived 还会继续挂在主节点上运行，这时请求网站时，网站是不能访问的，这时需要将 Nginx 重新启动，否则网站是不能访问的，如果 Nginx 不能再次启动，这时就需要将 Keepalived 主节点切换成备用节点。这时就需要写一个脚本，来实现这个功能。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Keepalived自动重启Nginx服务</h2>

<blockquote>
<p>将自动重启 Nginx 服务的脚本写在 Keepalived 主配置文件同级目录下（/etc/keepalived）</p>
</blockquote>

<p><strong>检测 Nginx 服务是否存活脚本如下：</strong></p>

<pre><code class="language-text">file_name check_nginx_alive_or_not.sh

#!/bin/bash
A=`ps -C nginx --no-header | wc -l`
# 判断 nginx 是否宕机，如果宕机了，尝试重启
if [ $A -eq 0 ];then
    /usr/local/nginx/sbin/nginx
    # 等待一小会再次检查 nginx，如果没有启动成功，则停止Keepalived，使其启动备用机
    sleep 3
    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then
        killall keepalived
    fi
fi
</code></pre>

<p><strong>然后到 Keepalived 主配置文件内添加一个脚本的监听。</strong></p>

<blockquote>
<p>在主配置文件中定一个脚本：vrrp_script，然后在 VI_1 节点配置调用。<br/>
配置完成后重启Keepalived：systemctl restart keepalived</p>
</blockquote>

<pre><code class="language-text">! 全局配置
global_defs {
   ! 配置切换通知的email
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   ! 配置发件人
   notification_email_from Alexandre.Cassen@firewall.loc
   ! 配置邮箱服务器地址
   smtp_server 192.168.200.1
   ! 配置链接邮箱服务器的超时时间
   smtp_connect_timeout 30
   ! 路由ID：当前安装Keepalived节点主机的标识符，全局唯一
   router_id LVS_DEVEL
   ! 全局vrrp协议配置
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

! 添加自动启动Nginx监听
vrrp_script check_nginx_alive {
    script &quot;/etc/keepalived/check_nginx_alive_or_not.sh&quot;
    ! 每隔两秒运行上一行脚本
    interval 2
    ! 如果脚本运行成功，则升级权重+10
    weight 10
    ! 如果脚本运行失败，则降级权重-10
    # weight -10
}

! 计算机节点，基于vrrp协议的一个实例
vrrp_instance VI_1 {
    ! 表示状态，当前服务器的nginx的主节点，MASTER/BACKUP
    state MASTER
    ! 当前实例绑定的网卡
    interface eth0
    ! 保证主备节点一致即可
    virtual_router_id 51
    ! 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选
    priority 100
    ! 主备之间同步检查时间间隔，单位秒
    advert_int 2
    ! 认证权限密码。防止非法节点进入
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    
    track_script {
        check_nginx_alive # 追踪 nginx 脚本
    }
    
    ! 虚拟出来的ip，可以有多个（vip）
    virtual_ipaddress {
        192.168.200.16
        192.168.200.17
        192.168.200.18
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keepalived]]></title>
    <link href="jythons.github.io/16042148155872.html"/>
    <updated>2020-11-01T15:13:35+08:00</updated>
    <id>jythons.github.io/16042148155872.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">IP规划</h2>

<p><img src="media/16042148155872/keepalived-IP%E8%A7%84%E5%88%92.png" alt="keepalived-IP规划"/></p>

<blockquote>
<p>keepalived官网<a href="https://www.keepalived.org/index.html">地址</a></p>
</blockquote>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装Keepalived</h2>

<ol>
<li><a href="https://www.keepalived.org/software/keepalived-2.1.5.tar.gz">下载安装包</a></li>
<li>解压：tar -zxvf keepalived-2.1.5.tar.gz</li>
<li>cd keepalived-2.1.5</li>
<li>./configure --prefix=/usr/local/keepalived --sysconf=/etc</li>
<li>make &amp;&amp; make install</li>
</ol>

<blockquote>
<p>--prefix: 安装目录；--sysconf: 同步核心配置到/etc目录下，<code>/etc/keepalived/keepalived.conf</code>，固定位置，改成其他位置则keepalived启动不了，<code>/var/log/messages</code>中会报错。<br/>
配置过程中可能会出现警告信息，如下所示：<br/>
<code>*** WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-devel ...</code><br/>
解决办法：安装libnl/libnl-3依赖，<code>yum -y install libnl libnl-devel</code>, 然后重新安装步骤的第4步和第五部一下，此时OK。</p>
</blockquote>

<h2 id="toc_2">Keepalived 核心配置文件</h2>

<pre><code class="language-text">! 全局配置
global_defs {
   ! 配置切换通知的email
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   ! 配置发件人
   notification_email_from Alexandre.Cassen@firewall.loc
   ! 配置邮箱服务器地址
   smtp_server 192.168.200.1
   ! 配置链接邮箱服务器的超时时间
   smtp_connect_timeout 30
   ! 路由ID：当前安装Keepalived节点主机的标识符，全局唯一
   router_id LVS_DEVEL
   ! 全局vrrp协议配置
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}
! 计算机节点，基于vrrp协议的一个实例
vrrp_instance VI_1 {
    ! 表示状态，当前服务器的nginx的主节点，MASTER/BACKUP
    state MASTER
    ! 当前实例绑定的网卡
    interface eth0
    ! 保证主备节点一致即可
    virtual_router_id 51
    ! 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选
    priority 100
    ! 主备之间同步检查时间间隔，单位秒
    advert_int 2
    ! 认证权限密码。防止非法节点进入
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    ! 虚拟出来的ip，可以有多个（vip）
    virtual_ipaddress {
        192.168.200.16
        192.168.200.17
        192.168.200.18
    }
}
! 下方都是虚拟主机，这里不需要可以删除
virtual_server 192.168.200.100 443 {
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.201.100 443 {
        weight 1
        SSL_GET {
            url {
              path /
              digest ff20ad2481f97b1754ef3e12ecd3a9cc
            }
            url {
              path /mrtg/
              digest 9b3a0c85a887a256d6939da88aabd8cd
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
}

virtual_server 10.10.10.2 1358 {
    delay_loop 6
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    sorry_server 192.168.200.200 1358

    real_server 192.168.200.2 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
    
    real_server 192.168.200.3 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334c
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
}

virtual_server 10.10.10.3 1358 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 192.168.200.4 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
    
    real_server 192.168.200.5 1358 {
        weight 1
        HTTP_GET {
            url {
              path /testurl/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl2/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            url {
              path /testurl3/test.jsp
              digest 640205b7b0fc66c1ea91c463fac6334d
            }
            connect_timeout 3
            retry 3
            delay_before_retry 3
        }
    }
}
</code></pre>

<h2 id="toc_3">启动 Keepalived</h2>

<pre><code class="language-text">cd /usr/local/keepalived/sbin
./keepalived
</code></pre>

<h2 id="toc_4">关闭 Keepalived</h2>

<p><code>ps -ef | grep keepalived</code>, 查出进程号，直接kill -9 进程ID。</p>

<h2 id="toc_5">Keepalived 注册为系统服务</h2>

<p>进入Keepalived的安装目录（安装包解压后的文件夹内），里面有一个keepalived文件夹，进入，里面有一个 etc 文件夹。拷贝 etc/init.d/keepalived 到系统目录/etc/init.d/ 文件夹下。</p>

<pre><code class="language-shell">cp ./keepalived/etc/init.d/keepalived /etc/init.d/
cp ./keepalived/etc/sysconfig/keepalived /etc/sysconfig/
</code></pre>

<p>然后刷新系统服务，使刚加进去的服务生效。</p>

<pre><code class="language-text">systemctl daemon-reload
</code></pre>

<p>这样就可以在系统服务中使用Keepalived了。</p>

<h3 id="toc_6">系统中使用Keepalived</h3>

<pre><code class="language-text">systemctl start keepalived.service    # 启动Keepalived服务
systemctl stop keepalived.service     # 停止Keepalived服务
systemctl restart keepalived.service  # 重新启动Keepalived服务
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx高可用集群架构]]></title>
    <link href="jythons.github.io/16042095103845.html"/>
    <updated>2020-11-01T13:45:10+08:00</updated>
    <id>jythons.github.io/16042095103845.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">高可用 HA（High Availability）</h2>

<h3 id="toc_1">Keepalived双机主备原理</h3>

<p>反向代理服务器，分为主节点和一个备用节点，当主节点挂掉之后，自动切换为备用节点。<br/>
<img src="media/16042095103845/HA%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="HA高可用"/><br/>
<span id="more"></span><!-- more --></p>

<h3 id="toc_2">Keepalived概念</h3>

<ul>
<li>解决单点故障，不单单是在nginx上使用，也可以在redis等集群服务上使用。</li>
<li>组件免费</li>
<li>可以实现高可用HA机制</li>
<li>基于VRRP协议</li>
</ul>

<h3 id="toc_3">虚拟路由冗余协议 VRRP</h3>

<blockquote>
<p>VRRP即虚拟路由冗余协议(Virtual Router Redundancy Protocol)，它是为了避免路由器出现单点故障的一种容错协议。 </p>
</blockquote>

<ul>
<li>解决内网单机故障的路由协议</li>
<li>通过该协议，可以构建有多个路由器 MASTER BACKUP</li>
<li>虚拟IP - VIP（Virtual IP Address）</li>
</ul>

<h3 id="toc_4">Keepalived双机主备原理</h3>

<p>用户以前是直接请求到Nginx，有了Keepalived之后，用户先请求到虚拟IP，由于虚拟IP是和Nginx的Master节点绑定的，所以，请求会到达Master节点的Nginx。<br/><br/>
<img src="media/16042095103845/%E8%99%9A%E6%8B%9FIP%E8%AE%BF%E9%97%AEMaster-nginx.png" alt="虚拟IP访问Master-nginx"/></p>

<p>虚拟IP会对Nginx做心跳检测，如果主节点Nginx挂掉之后，虚拟IP就会和Nginx的备用节点绑定，用户的请求还是先请求到虚拟IP，然后请求到备用节点的Nginx。<br/>
<img src="media/16042095103845/%E8%99%9A%E6%8B%9FIP%E8%AE%BF%E9%97%AE%E5%A4%87%E7%94%A8Nginx%E8%8A%82%E7%82%B9.png" alt="虚拟IP访问备用Nginx节点"/></p>

<blockquote>
<p>不管是使用多个还是一个备用节点，要保证备用节点的配置和主节点的服务器配置是相同的。<br/>
例如，主节点可以同时处理1000个请求，备用节点可以同时处理100个请求，当主节点挂掉之后，请求会全部打到备用节点，这时由于备用节点的配置比较低，不能同时处理100个以上的请求，因此，备用节点会瞬间挂掉。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动静分离的那些事]]></title>
    <link href="jythons.github.io/16042031909226.html"/>
    <updated>2020-11-01T11:59:50+08:00</updated>
    <id>jythons.github.io/16042031909226.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">动静分离的特点</h2>

<h3 id="toc_1">分布式</h3>

<p>动静分离的本质就是分布式，把动态接口和静态的资源分开这样的话就可以减少后台服务器的压力，提高了静态资源的访问速度，因为静态资源是可以被缓存的，一旦有了缓存的话，用户访问的速度就回更快。后端就不需要再去渲染页面，以往的开发，html、jsp是需要服务器去渲染的，现在采用动静分离，静态资源都是交给客户端去渲染。<br/>
<span id="more"></span><!-- more --></p>

<h3 id="toc_2">前后端解耦</h3>

<p>前后端分离的开发模式，前后端分开开发，分开部署。</p>

<h3 id="toc_3">静态归Nginx</h3>

<p>静态资源，例如：js、css、html等静态资源都交由Nginx管理，从Nginx里面去读去和加载静态资源的。</p>

<h3 id="toc_4">接口的服务化</h3>

<p>因为是动静分离，所以接口都是单独的去部署，通过集群去部署，这样就可以封装一些接口和数据，让前端去调用。</p>

<h2 id="toc_5">动静分离</h2>

<h3 id="toc_6">静态数据</h3>

<p>例如像css、js、html、images、audios、videos这些，如果需要修改，Nginx会根据最后一次的修改时间来刷新数据。</p>

<h3 id="toc_7">动态数据</h3>

<p>动态数据往往都是以一个接口的形式去请求，动态数据可能第一次去请求和第二次去请求获得的结果是一样的。例如文章，文章列表数据。</p>

<h2 id="toc_8">动静分离的方式</h2>

<h3 id="toc_9">CDN</h3>

<p>CDN是一个内容分发网络，他可以根据客户端的地域去选择最近的服务器来获取资源，加速访问速度。</p>

<h3 id="toc_10">Nginx</h3>

<p>根据url来判断请求的是静态资源还是动态资源，如果是请求的静态资源，就将请求转发到静态资源集群，如果请求的动态资源，就将请求转发到动态资源的上游服务器。</p>

<h2 id="toc_11">动静分离的问题</h2>

<h3 id="toc_12">跨域</h3>

<p>解决方式：</p>

<ul>
<li>SpringBoot</li>
<li>Nginx</li>
<li>jsonp</li>
</ul>

<h3 id="toc_13">分布式会话</h3>

<ul>
<li>分布式缓存中间件，例如：redis</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx中配置SSL证书]]></title>
    <link href="jythons.github.io/16041606361898.html"/>
    <updated>2020-11-01T00:10:36+08:00</updated>
    <id>jythons.github.io/16041606361898.html</id>
    <content type="html"><![CDATA[
<p>Nginx默认访问使用的是http协议，如果要使用https协议，需要为网站配置SSL证书，因为https是安全的，对传输的数据进行了加密。使用https，必须要有一个域名，并且域名需要备案之后才可以使用。<br/>
申请完SSL证书后，会得到两个文件，一个是.crt后缀的文件是证书文件，还有一个是.key文件，是密钥文件。<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0">新增Nginx的SSL模块</h2>

<blockquote>
<p>要在nginx中配置https，就必须安装ssl模块，也就是：http_ssl_module。</p>
</blockquote>

<ul>
<li>进入到nginx的解压目录：/home/jythons/package/nginx-1.18.0</li>
<li>新增ssl模块（原来的那些模块需要保留）</li>
</ul>

<pre><code class="language-text">./configure \
--prefix=/usr/local/nginx \
--pid-path=/var/run/nginx/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--with-http_gzip_static_module \
--http-client-body-temp-path=/var/temp/nginx/client \
--http-proxy-temp-path=/var/temp/nginx/proxy \
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
--http-scgi-temp-path=/var/temp/nginx/scgi \
--with-http_ssl_module

</code></pre>

<ul>
<li>编译和安装</li>
</ul>

<pre><code class="language-text">make
make install
</code></pre>

<h2 id="toc_1">Nginx配置HTTPS</h2>

<ul>
<li>把ssl证书 *.crt和私钥 *.key 拷贝到/usr/local/nginx/conf 目录中。</li>
<li>新增server监听443端口</li>
</ul>

<pre><code class="language-text">#配置上游服务器
upstream tomcats {
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

server {
    listen 443;
    server_name www.tomcats.com;
    
    # 开启ssl
    ssl on;
    # 配置ssl证书
    ssl_certificate 1_www.tomcats.com_bundle.crt;
    # 配置证书密钥
    ssl_certificate_key 1_www.tomcats.com.key;
    
    # ssl会话cache
    ssl_session_cache shared:SSL:1m;
    # ssl会话超时时间
    ssl_session_timeout 5m;
    
    # 配置加密套件，写法遵循openssl标准
    ssl_protocols TLSv1.1 TLSv1.2;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
    ssl_prefer_server_ciphers on;
    
    location / {
        proxy_pass http://tomcats/;
        index index.html index.htm;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx控制浏览器缓存]]></title>
    <link href="jythons.github.io/16038978992618.html"/>
    <updated>2020-10-28T23:11:39+08:00</updated>
    <id>jythons.github.io/16038978992618.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">原理图</h2>

<p><img src="media/16038978992618/Nginx%E6%8E%A7%E5%88%B6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.png" alt="Nginx控制浏览器缓存"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">设置缓存的指令：expires指令</h2>

<p>expires [time] 设置多少秒后缓存过期；例：expires 10s<br/>
expires @[time] 设置到那个时间点缓存过期；例：expires @22h30m<br/>
expires -[time] 表示在现在缓存的多长时间以前就过期；例：expires -1h<br/>
expires epoch 表示不去缓存<br/>
expires off 表示Nginx端关闭缓存，在浏览器上不会体现出来；<br/>
expires max 表示缓存的一个最大的时间，表示永不过期。</p>

<h2 id="toc_2">在Nginx中的使用方法</h2>

<pre><code class="language-text">location /static {
    alias /home/static;
    expires 10s;
}
</code></pre>

<p><img src="media/16038978992618/header%E6%98%BE%E7%A4%BA%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.png" alt="header显示过期时间"/></p>

<h2 id="toc_3">Nginx反向代理缓存</h2>

<pre><code class="language-text">#配置上游服务器
upstream tomcats {
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

# 设置缓存保存的目录, 
# keys_zone 设置共享内存空间，和大小
# max_size 设置缓存大小
# inactive 超过此时间，则缓存自动清理, 8h:8小时，8m:8分钟，8s:8秒
# use_temp_path 关闭临时目录，临时目录会对nginx造成性能影响
proxy_cache_path /usr/local/nginx/upsteam_cache keys_zone=mycache:5m max_size=1g inactive=8h use_temp_path=off;

server {
        listen 80;
        server_name www.tomcats.com;
        
        # 开启并且使用缓存，mycache对应上方proxy_cache_path配置
        proxy_cache mycache;
        # 针对200和304状态码，设置缓存过期时间
        proxy_cache_valid 200 304 8h
        
        location / {
                proxy_pass http://tomcats;
        }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[负载均衡之url_hash]]></title>
    <link href="jythons.github.io/16038966099434.html"/>
    <updated>2020-10-28T22:50:09+08:00</updated>
    <id>jythons.github.io/16038966099434.html</id>
    <content type="html"><![CDATA[
<p>从字面上可以看出，他是基于URL的hash算法，根据URL获得的hash值将请求分配到不同的节点上<br/>
<img src="media/16038966099434/URL-hash.png" alt="URL-hash"/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">Nginx配置</h2>

<pre><code class="language-text">upstream tomcats {
        hash $request_uri; 
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

server {
        listen 80;
        server_name www.tomcats.com;

        location / {
                proxy_pass http://tomcats;
        }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[负载均衡之ip_hash]]></title>
    <link href="jythons.github.io/16038139816578.html"/>
    <updated>2020-10-27T23:53:01+08:00</updated>
    <id>jythons.github.io/16038139816578.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">hash算法</h2>

<blockquote>
<p>hash(ip) % node_counts = index<br/>
通过对客户端IP进行哈希然后根据上方公式分配到对应的服务器处理，之后的每次请求，只要客户端的IP没有变化，所有的请求都会请求到这台服务器上。<br/>
由于nginx的ip_hash算法是根据IP的前三个数值进行的hash，所以内网使用时，只会访问同一台服务器上。如果有人进行不正当的大量请求，这时所有的请求都会转发到同一台服务器上，这时会造成这台服务器的负载升高。<br/>
当使用ip_hash的方式进行负载均衡时，如果要临时移除一台服务器时，不能直接将这个server删除，要将这要服务器标记为down。<br/>
该算法，在增加或减少节点时，都需要重新计算。</p>
</blockquote>

<span id="more"></span><!-- more -->

<pre><code class="language-text">upstream tomcats {
        ip_hash; # 使用ip_hash的方式实现负载均衡
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell编程]]></title>
    <link href="jythons.github.io/16038138353128.html"/>
    <updated>2020-10-27T23:50:35+08:00</updated>
    <id>jythons.github.io/16038138353128.html</id>
    <content type="html"><![CDATA[
<p>总结一下shell编程的语法规则以及注意事项。<br/>
<span id="more"></span><!-- more --></p>

<ul>
<li>定义<strong>变量</strong>时，不使用<code>$</code>，等号两边不能有空格,使用变量时使用<code>$</code>。<br/></li>
</ul>

<pre><code class="language-shell">例如：
val=&#39;abc&#39;   (正确)
val = &#39;abc&#39; (错误) 
echo ${val} (使用变量)
</code></pre>

<ul>
<li><strong>字符串：</strong></li>
</ul>

<pre><code class="language-shell">获取字符串长度:${#abc},结果返回3;截取字符串:${abc:1:2}。
例如：
str=&#39;abcdefg&#39;
echo ${str:1:2}
</code></pre>

<blockquote>
<p>结果返回：bc；意思是重二个字符开始，截取两个字符；这里是重0开始计算的。</p>
</blockquote>

<ul>
<li><p><strong>数组：</strong>  </p>
<pre><code class="language-bash">定义数组：arr=(val1 val2 val3 ... valn) 或 arr[0]=val0
使用数组元素：${arr[0]}  <br/>
输出数组元素：${arr[*]} 或 ${arr[@]}  <br/>
获取数组长度：${#arr[*]} 或 ${#arr[@]}
</code></pre></li>
<li><p><strong>运算符</strong>  </p>
<blockquote>
<p>计算数值时使用：<code>expr 表达式</code> 或 <code>$((表达式))</code>，如果使用 <code>expr</code> 时，乘法使用 <code>\*</code>，使用运算符时，使用<code>[]</code>,并且运算符两边都要有空格，例如：<code>if [ $a -eq $b ] then fi</code></p>
</blockquote></li>
</ul>

<h6 id="toc_0">关系运算符</h6>

<pre><code class="language-text">-eq 检测两个数是都相等，相等返回 true  
-ne 检测两个数是都相等，不相等返回true  
-gt 大于号  
-lt 小于号  
-ge 大于等于
-le 小于等于
</code></pre>

<h6 id="toc_1">布尔运算符</h6>

<pre><code class="language-text">!  非  
-o 或  
-a 与
</code></pre>

<h6 id="toc_2">逻辑运算符</h6>

<pre><code class="language-text">&amp;&amp; 逻辑的AND
|| 逻辑的OR
</code></pre>

<blockquote>
<p>注意：使用逻辑运算符时，if语句需要使用<code>[[ 表达式 ]]</code>；  </p>
</blockquote>

<pre><code class="language-shell">例如：
a=10
b=10
if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
    echo &quot;返回 true&quot;
else
    echo &quot;返回 false&quot;
fi
</code></pre>

<h6 id="toc_3">字符串运算符</h6>

<pre><code class="language-text">=   检测两个字符串是否相等，相等返回true    例：[ $a = $b ]  
!=  检测两个字符串是否相等，不相等返回true  例：[ $a != $b ]  
-z  检测字符串长度是否为0，为0返回true　　　例：[ -z $a ]  
-n  检测字符串长度是否为0，不为0返回true    例：[ -n $a ]  
str 检测字符串是否为空，不为空返回true      例：[ $a ]  
</code></pre>

<h6 id="toc_4">文件测试运算符</h6>

<blockquote>
<p>$file 为文件路径</p>
</blockquote>

<pre><code class="language-shell">[ -b $file ] 检测文件是否是块设备文件，是返回true  
[ -c $file ] 检测文件是否是字符设备文件，如果是，则返回 true  
[ -d $file ] 检测文件是否是目录，如果是，则返回 true  
[ -f $file ] 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true  
[ -g $file ] 检测文件是否设置了 SGID 位，如果是，则返回 true  
[ -k $file ] 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true  
[ -p $file ] 检测文件是否是有名管道，如果是，则返回 true  
[ -u $file ] 检测文件是否设置了 SUID 位，如果是，则返回 true  
[ -r $file ] 检测文件是否可读，如果是，则返回 true  
[ -w $file ] 检测文件是否可写，如果是，则返回 true  
[ -x $file ] 检测文件是否可执行，如果是，则返回 true  
[ -s $file ] 检测文件是否为空（文件大小是否大于0），不为空返回 true
[ -e $file ] 检测文件（包括目录）是否存在，如果是，则返回 true
</code></pre>

<ul>
<li><p><strong>test命令</strong><br/><br/>
<code>[]</code>作为基本运算符使用时，内部不能有空格  </p>
<pre><code class="language-shell">例如：  
a=5<br/>
b=5<br/>
res=$[a+b]<br/>
echo $res # 结果为10
</code></pre></li>
<li><p><strong>read</strong><br/><br/>
<code>read</code> 等待用户输入。  </p></li>
</ul>

<pre><code class="language-shell">例：
#!/bin/sh
read name
echo &quot;输入的值name等于 ${name}&quot;
</code></pre>

<ul>
<li><strong>流程控制</strong><br/>
###### if语句：<br/></li>
</ul>

<pre><code class="language-shell">if condition
then
    command
fi
写成一行：if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi

if else:
if condition
then
    command1
else
    command2
fi

if else-if else:
if condition1
then
    command1
elif condition2
then
    command2
else
    command3
fi
</code></pre>

<h6 id="toc_5">for循环</h6>

<pre><code class="language-shell">for var in item1 item2 ... itemN
do
    command1
    ...
    commandN
done

写成一行：for var in item1 ... itemN; do cmooand1;command2... done;
</code></pre>

<h6 id="toc_6">while循环，与until循环用法相同（结果为真时退出循环）</h6>

<pre><code class="language-shell">例：
#!/bin/sh
int=1
while(( $int&lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done
</code></pre>

<blockquote>
<p>使用了 <code>let</code> 命令，用于执行一个或多个表达式，变量计算中不需要加上 <code>$</code> 来表示变量。</p>
</blockquote>

<h6 id="toc_7">case</h6>

<pre><code class="language-shell">例：
read aNum
case $aNum in
    1) echo &#39;1&#39;
    ;;  # 两个；表示break，跳出
    2|3) echo &#39;2&#39;
    ;;
    *) echo &#39;none&#39;
        break # 跳出所有循环，continue跳出当前循环
    ;;
esac
</code></pre>

<ul>
<li><strong>函数</strong><br/>
###### 定义函数</li>
</ul>

<pre><code class="language-shell">[function] funcName[()]{
    command
    [return n] # n为0-255之间的数字
}

funcName  # 调用函数funcName
</code></pre>

<blockquote>
<p>1.可以带function fun()定义，也可以直接fun()定义，不到任何参数<br/><br/>
2.参数返回，可以显示的加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。</p>
</blockquote>

<pre><code class="language-shell">例：
#!/bin/sh
function funcName(){
    echo &#39;this is a function!&#39;
}
# 开始执行函数
funcName
# 函数执行结束
</code></pre>

<h6 id="toc_8">函数参数</h6>

<pre><code class="language-shell">例：
funWithParam(){
    echo &quot;第一个参数：$1&quot;
    echo &quot;第二个参数：$2&quot;
    echo &quot;第五个参数：${5}&quot;
    echo &quot;参数总个数：$#&quot;
    echo &quot;作为字符串输出所有参数：$* !&quot;
}
funWidthParam 1 2 3 4 5 6 7  #调用函数传参
</code></pre>

<blockquote>
<p>备注：<code>$#</code> 传递到脚本的参数个数<br/><br/>
<code>$*</code> 以一个单字符串显示所有向脚本传递的参数；<br/><br/>
<code>$$</code> 脚本运行的当前进程ID号；<br/><br/>
<code>$!</code> 后台运行的最优一个进程的ID号<br/><br/>
<code>$@</code> 与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数；<br/><br/>
<code>$-</code> 显示<code>Shell</code>使用的当前选项，与<code>set</code>命令功能相同<br/><br/>
<code>$?</code> 显示最后命令的退出状态。<code>0</code>表示没有错误，其他任何值表明有错误。</p>
</blockquote>

<ul>
<li><strong>Shell文件包含</strong><br/>
Shell包含外部脚本语法合适如下：</li>
</ul>

<pre><code class="language-shell">. filename    # 注意点号（.）和文件名中间有一个空格
或
source filename
</code></pre>

<blockquote>
<p><strong>注：</strong>被包含的文件不需要可执行权限</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一致性哈希算法]]></title>
    <link href="jythons.github.io/16038127730075.html"/>
    <updated>2020-10-27T23:32:53+08:00</updated>
    <id>jythons.github.io/16038127730075.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>根据hash算法，对服务器节点进行hsah，然后放到一个顺时针闭环上，当用户访问时，通过hash，顺时针找到距离他最近的节点</p>
</blockquote>

<span id="more"></span><!-- more -->

<p><img src="media/16038127730075/%E4%B8%80%E8%87%B4%E6%80%A7hash.png" alt="一致性hash"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx Tomcat集群搭建]]></title>
    <link href="jythons.github.io/16032063964658.html"/>
    <updated>2020-10-20T23:06:36+08:00</updated>
    <id>jythons.github.io/16032063964658.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">Nginx配置</h2>

<pre><code class="language-text">#配置上游服务器
upstream tomcats {
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
}

server {
        listen 80;
        server_name www.tomcats.com;

        location / {
                proxy_pass http://tomcats;
        }
}
</code></pre>

<h2 id="toc_1">使用JMeter测试但节点与集群并发异常率</h2>

<p>JMeter是apache的一个基于java的测试工具<br/>
下载地址：<a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a></p>

<h2 id="toc_2">负载均衡之轮询</h2>

<p>nginx负载均衡默认的策略是轮询</p>

<h2 id="toc_3">负载均衡之加权轮询</h2>

<p>通过配置权重，来实现轮训，权重越大，被分配流量越多。</p>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080 weight=1;
        server 192.168.3.27:8080 weight=2;
        server 192.168.3.28:8080 weight=5;
}
</code></pre>

<h2 id="toc_4">upstream指令参数</h2>

<h3 id="toc_5">max_conns</h3>

<blockquote>
<p>指配置到上游的每个服务器的最大链接数，根据每个服务器能够承受的最大流量，起到保险丝的作用。默认值是0，代表不做任何限制。1.11.5版本之前只有商业版才能使用。如果是在共享内存使用的话，nginx每个work工作进程都可以使用。</p>
</blockquote>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080 max_conns=1;
        server 192.168.3.27:8080 max_conns=2;
        server 192.168.3.28:8080 max_conns=5;
}
</code></pre>

<h3 id="toc_6">slow_start</h3>

<blockquote>
<p>慢启动，主要用于，当某个服务器加入到集群后，不希望直接加入，需要启动一些软件之后在加入到集群，例如：启动监控服务等。如果该服务器配置的权重是10，设置了该值之后，他会慢慢的将权重加到10，对于hash和random方式的负载均衡是不支持的。对于单个服务器，这个参数是不适用的，需要至少有两个才行。 (商业版才能使用这个参数)</p>
</blockquote>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080 weight=6 slow_start=60s;
        server 192.168.3.27:8080 weight=2;
        server 192.168.3.28:8080 weight=2;
}
</code></pre>

<h3 id="toc_7">down</h3>

<blockquote>
<p>标识服务器为不可用状态。</p>
</blockquote>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080 down;
        server 192.168.3.27:8080 weight=2;
        server 192.168.3.28:8080 weight=2;
}
</code></pre>

<h3 id="toc_8">backup</h3>

<blockquote>
<p>标识服务器只有在其他服务器挂掉之后才会启用，相当于备用机。</p>
</blockquote>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080 backup;
        server 192.168.3.27:8080 weight=2;
        server 192.168.3.28:8080 weight=2;
}
</code></pre>

<h3 id="toc_9">max_fails</h3>

<blockquote>
<p>最大失败次数，如果服务器请求失败次数，达到最大的失败次数，那么nginx就会把对应的服务器剔除，请求就不会到达该服务器。</p>

<h3 id="toc_10">fail_timeout</h3>

<p>配合<code>max_fails</code>参数使用，当请求失败次数达到最大时，在接下来的错误时间段内，请求不会到达这台服务器，等到<code>fail_timeout</code>时间之后，nginx会再次尝试请求这台服务器。</p>
</blockquote>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080 max_fails=2 fail_timeout=15s;
        server 192.168.3.27:8080 max_fails=2 fail_timeout=15s;
        server 192.168.3.28:8080 max_fails=2 fail_timeout=15s;
}
</code></pre>

<h2 id="toc_11">使用Keepalived提高吞吐量</h2>

<blockquote>
<p>Keepalive的作用是将链接作为长链接，大大的减少了链接创建和断开时间上的消耗。</p>
</blockquote>

<pre><code class="language-text">upstream tomcats {
        server 192.168.3.26:8080;
        server 192.168.3.27:8080;
        server 192.168.3.28:8080;
        keepalive 32;
}

server {
        listen 80;
        server_name www.tomcats.com;

        location / {
                proxy_pass http://tomcats;
                proxy_http_version 1.1; #http 版本
                proxy_set_header Connection &quot;&quot;; #清空header Connection参数内容
        }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx的集群负载均衡解析]]></title>
    <link href="jythons.github.io/16031997211070.html"/>
    <updated>2020-10-20T21:15:21+08:00</updated>
    <id>jythons.github.io/16031997211070.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->

<h2 id="toc_0">单节点</h2>

<p>服务器挂了，服务停止</p>

<h2 id="toc_1">集群</h2>

<p>一台服务器挂了，服务还可以继续执行</p>

<h2 id="toc_2">Nginx集群负载均衡</h2>

<p>客户端不会直接访问到服务，会先经过nginx反向代理，由nginx分配请求到后端的服务器。</p>

<h2 id="toc_3">四层负载均衡</h2>

<p>基于IP+端口的负载均衡，通过转发请求到后台服务器，并记录请求是那个服务器处理的，后续的请求会使用同一台服务器去处理，四层负载均衡是在传输层的，主要基于TCP和UDP</p>

<h3 id="toc_4">F5硬负载均衡</h3>

<p>优点：基于硬件的，功能强大，性能和稳定性比较高。<br/>
缺点：价格昂贵，商业级别的</p>

<h3 id="toc_5">LVS四层负载均衡</h3>

<p>Linux内核的，和协议没有什么关系</p>

<h3 id="toc_6">Haproxy 四层负载均衡</h3>

<p>支持转发功能，灵活性高，除了四层以外还可以做7层的负载均衡</p>

<h3 id="toc_7">Nginx四层负载均衡</h3>

<p>通常使用Nginx做7层负载均衡，以7层为主，基于HTTP做的负载均衡，老版本是在1.9版本后加了一个stream模块，可以实现4层协议的转发代理。</p>

<h2 id="toc_8">七层负载均衡</h2>

<h3 id="toc_9">Nginx七层负载均衡</h3>

<p>对http和mail协议做负载均衡</p>

<h3 id="toc_10">Haproxy七层负载均衡</h3>

<h3 id="toc_11">apache七层负载均衡</h3>

<p>性能远不如nginx的高，当并发达到百万级别以后，性能会越来越差</p>

<h2 id="toc_12">DNS地域负载均衡</h2>

<p>举例：在浏览器打开一个网址，先请求DNS服务器，DNS会根据我当前所在的地域，根据就近原则，返回一个最近的IP地址</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx的模块化体系]]></title>
    <link href="jythons.github.io/15985425740195.html"/>
    <updated>2020-08-27T23:36:14+08:00</updated>
    <id>jythons.github.io/15985425740195.html</id>
    <content type="html"><![CDATA[
<ul>
<li>event module 事件模块，操作系统层面的事件处理机制</li>
<li>phase handle 用于处理客户端的请求，以及相应内容的响应</li>
<li>output filter 返回响应时，需要通过该模块，相当于过滤器，例如：gzip，将大的文件过滤成小的文件</li>
<li>upstream 反向代理模块，会把服务器请求转发到真实的服务器地址</li>
<li>load balancer 负载均衡器，实现集群和负载均衡的配置</li>
<li>extend module 继承模块，使用第三方模块时需要用到</li>
</ul>

<span id="more"></span><!-- more -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx中配置静态资源防盗链]]></title>
    <link href="jythons.github.io/15985421341710.html"/>
    <updated>2020-08-27T23:28:54+08:00</updated>
    <id>jythons.github.io/15985421341710.html</id>
    <content type="html"><![CDATA[
<p>配置防盗链也是在Nginx.conf配置文件的Server配置块内配置如下信息：<br/>
<span id="more"></span><!-- more --></p>

<pre><code class="language-text">#对源站点验证
valid_referers *.imooc.com;
#非法引入会进入下放判断
if ($invalid_referer) {
    return 404;
}
</code></pre>

]]></content>
  </entry>
  
</feed>
